/**
 * Mozilla Public License, version 2.0
 *
 * 1. Definitions
 *
 * 1.1. “Contributor”
 *
 *      means each individual or legal entity that creates, contributes to the
 *      creation of, or owns Covered Software.
 *
 * 1.2. “Contributor Version”
 *
 *      means the combination of the Contributions of others (if any) used by a
 *      Contributor and that particular Contributor’s Contribution.
 *
 * 1.3. “Contribution”
 *
 *      means Covered Software of a particular Contributor.
 *
 * 1.4. “Covered Software”
 *
 *      means Source Code Form to which the initial Contributor has attached the
 *      notice in Exhibit A, the Executable Form of such Source Code Form, and
 *      Modifications of such Source Code Form, in each case including portions
 *      thereof.
 *
 * 1.5. “Incompatible With Secondary Licenses”
 *      means
 *
 *      a. that the initial Contributor has attached the notice described in
 *         Exhibit B to the Covered Software; or
 *
 *      b. that the Covered Software was made available under the terms of version
 *         1.1 or earlier of the License, but not also under the terms of a
 *         Secondary License.
 *
 * 1.6. “Executable Form”
 *
 *      means any form of the work other than Source Code Form.
 *
 * 1.7. “Larger Work”
 *
 *      means a work that combines Covered Software with other material, in a separate
 *      file or files, that is not Covered Software.
 *
 * 1.8. “License”
 *
 *      means this document.
 *
 * 1.9. “Licensable”
 *
 *      means having the right to grant, to the maximum extent possible, whether at the
 *      time of the initial grant or subsequently, any and all of the rights conveyed by
 *      this License.
 *
 * 1.10. “Modifications”
 *
 *      means any of the following:
 *
 *      a. any file in Source Code Form that results from an addition to, deletion
 *         from, or modification of the contents of Covered Software; or
 *
 *      b. any new file in Source Code Form that contains any Covered Software.
 *
 * 1.11. “Patent Claims” of a Contributor
 *
 *       means any patent claim(s), including without limitation, method, process,
 *       and apparatus claims, in any patent Licensable by such Contributor that
 *       would be infringed, but for the grant of the License, by the making,
 *       using, selling, offering for sale, having made, import, or transfer of
 *       either its Contributions or its Contributor Version.
 *
 * 1.12. “Secondary License”
 *
 *       means either the GNU General Public License, Version 2.0, the GNU Lesser
 *       General Public License, Version 2.1, the GNU Affero General Public
 *       License, Version 3.0, or any later versions of those licenses.
 *
 * 1.13. “Source Code Form”
 *
 *       means the form of the work preferred for making modifications.
 *
 * 1.14. “You” (or “Your”)
 *
 *       means an individual or a legal entity exercising rights under this
 *       License. For legal entities, “You” includes any entity that controls, is
 *       controlled by, or is under common control with You. For purposes of this
 *       definition, “control” means (a) the power, direct or indirect, to cause
 *       the direction or management of such entity, whether by contract or
 *       otherwise, or (b) ownership of more than fifty percent (50%) of the
 *       outstanding shares or beneficial ownership of such entity.
 *
 *
 * 2. License Grants and Conditions
 *
 * 2.1. Grants
 *
 *      Each Contributor hereby grants You a world-wide, royalty-free,
 *      non-exclusive license:
 *
 *      a. under intellectual property rights (other than patent or trademark)
 *         Licensable by such Contributor to use, reproduce, make available,
 *         modify, display, perform, distribute, and otherwise exploit its
 *         Contributions, either on an unmodified basis, with Modifications, or as
 *         part of a Larger Work; and
 *
 *      b. under Patent Claims of such Contributor to make, use, sell, offer for
 *         sale, have made, import, and otherwise transfer either its Contributions
 *         or its Contributor Version.
 *
 * 2.2. Effective Date
 *
 *      The licenses granted in Section 2.1 with respect to any Contribution become
 *      effective for each Contribution on the date the Contributor first distributes
 *      such Contribution.
 *
 * 2.3. Limitations on Grant Scope
 *
 *      The licenses granted in this Section 2 are the only rights granted under this
 *      License. No additional rights or licenses will be implied from the distribution
 *      or licensing of Covered Software under this License. Notwithstanding Section
 *      2.1(b) above, no patent license is granted by a Contributor:
 *
 *      a. for any code that a Contributor has removed from Covered Software; or
 *
 *      b. for infringements caused by: (i) Your and any other third party’s
 *         modifications of Covered Software, or (ii) the combination of its
 *         Contributions with other software (except as part of its Contributor
 *         Version); or
 *
 *      c. under Patent Claims infringed by Covered Software in the absence of its
 *         Contributions.
 *
 *      This License does not grant any rights in the trademarks, service marks, or
 *      logos of any Contributor (except as may be necessary to comply with the
 *      notice requirements in Section 3.4).
 *
 * 2.4. Subsequent Licenses
 *
 *      No Contributor makes additional grants as a result of Your choice to
 *      distribute the Covered Software under a subsequent version of this License
 *      (see Section 10.2) or under the terms of a Secondary License (if permitted
 *      under the terms of Section 3.3).
 *
 * 2.5. Representation
 *
 *      Each Contributor represents that the Contributor believes its Contributions
 *      are its original creation(s) or it has sufficient rights to grant the
 *      rights to its Contributions conveyed by this License.
 *
 * 2.6. Fair Use
 *
 *      This License is not intended to limit any rights You have under applicable
 *      copyright doctrines of fair use, fair dealing, or other equivalents.
 *
 * 2.7. Conditions
 *
 *      Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in
 *      Section 2.1.
 *
 *
 * 3. Responsibilities
 *
 * 3.1. Distribution of Source Form
 *
 *      All distribution of Covered Software in Source Code Form, including any
 *      Modifications that You create or to which You contribute, must be under the
 *      terms of this License. You must inform recipients that the Source Code Form
 *      of the Covered Software is governed by the terms of this License, and how
 *      they can obtain a copy of this License. You may not attempt to alter or
 *      restrict the recipients’ rights in the Source Code Form.
 *
 * 3.2. Distribution of Executable Form
 *
 *      If You distribute Covered Software in Executable Form then:
 *
 *      a. such Covered Software must also be made available in Source Code Form,
 *         as described in Section 3.1, and You must inform recipients of the
 *         Executable Form how they can obtain a copy of such Source Code Form by
 *         reasonable means in a timely manner, at a charge no more than the cost
 *         of distribution to the recipient; and
 *
 *      b. You may distribute such Executable Form under the terms of this License,
 *         or sublicense it under different terms, provided that the license for
 *         the Executable Form does not attempt to limit or alter the recipients’
 *         rights in the Source Code Form under this License.
 *
 * 3.3. Distribution of a Larger Work
 *
 *      You may create and distribute a Larger Work under terms of Your choice,
 *      provided that You also comply with the requirements of this License for the
 *      Covered Software. If the Larger Work is a combination of Covered Software
 *      with a work governed by one or more Secondary Licenses, and the Covered
 *      Software is not Incompatible With Secondary Licenses, this License permits
 *      You to additionally distribute such Covered Software under the terms of
 *      such Secondary License(s), so that the recipient of the Larger Work may, at
 *      their option, further distribute the Covered Software under the terms of
 *      either this License or such Secondary License(s).
 *
 * 3.4. Notices
 *
 *      You may not remove or alter the substance of any license notices (including
 *      copyright notices, patent notices, disclaimers of warranty, or limitations
 *      of liability) contained within the Source Code Form of the Covered
 *      Software, except that You may alter any license notices to the extent
 *      required to remedy known factual inaccuracies.
 *
 * 3.5. Application of Additional Terms
 *
 *      You may choose to offer, and to charge a fee for, warranty, support,
 *      indemnity or liability obligations to one or more recipients of Covered
 *      Software. However, You may do so only on Your own behalf, and not on behalf
 *      of any Contributor. You must make it absolutely clear that any such
 *      warranty, support, indemnity, or liability obligation is offered by You
 *      alone, and You hereby agree to indemnify every Contributor for any
 *      liability incurred by such Contributor as a result of warranty, support,
 *      indemnity or liability terms You offer. You may include additional
 *      disclaimers of warranty and limitations of liability specific to any
 *      jurisdiction.
 *
 * 4. Inability to Comply Due to Statute or Regulation
 *
 *    If it is impossible for You to comply with any of the terms of this License
 *    with respect to some or all of the Covered Software due to statute, judicial
 *    order, or regulation then You must: (a) comply with the terms of this License
 *    to the maximum extent possible; and (b) describe the limitations and the code
 *    they affect. Such description must be placed in a text file included with all
 *    distributions of the Covered Software under this License. Except to the
 *    extent prohibited by statute or regulation, such description must be
 *    sufficiently detailed for a recipient of ordinary skill to be able to
 *    understand it.
 *
 * 5. Termination
 *
 * 5.1. The rights granted under this License will terminate automatically if You
 *      fail to comply with any of its terms. However, if You become compliant,
 *      then the rights granted under this License from a particular Contributor
 *      are reinstated (a) provisionally, unless and until such Contributor
 *      explicitly and finally terminates Your grants, and (b) on an ongoing basis,
 *      if such Contributor fails to notify You of the non-compliance by some
 *      reasonable means prior to 60 days after You have come back into compliance.
 *      Moreover, Your grants from a particular Contributor are reinstated on an
 *      ongoing basis if such Contributor notifies You of the non-compliance by
 *      some reasonable means, this is the first time You have received notice of
 *      non-compliance with this License from such Contributor, and You become
 *      compliant prior to 30 days after Your receipt of the notice.
 *
 * 5.2. If You initiate litigation against any entity by asserting a patent
 *      infringement claim (excluding declaratory judgment actions, counter-claims,
 *      and cross-claims) alleging that a Contributor Version directly or
 *      indirectly infringes any patent, then the rights granted to You by any and
 *      all Contributors for the Covered Software under Section 2.1 of this License
 *      shall terminate.
 *
 * 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user
 *      license agreements (excluding distributors and resellers) which have been
 *      validly granted by You or Your distributors under this License prior to
 *      termination shall survive termination.
 *
 * 6. Disclaimer of Warranty
 *
 *    Covered Software is provided under this License on an “as is” basis, without
 *    warranty of any kind, either expressed, implied, or statutory, including,
 *    without limitation, warranties that the Covered Software is free of defects,
 *    merchantable, fit for a particular purpose or non-infringing. The entire
 *    risk as to the quality and performance of the Covered Software is with You.
 *    Should any Covered Software prove defective in any respect, You (not any
 *    Contributor) assume the cost of any necessary servicing, repair, or
 *    correction. This disclaimer of warranty constitutes an essential part of this
 *    License. No use of  any Covered Software is authorized under this License
 *    except under this disclaimer.
 *
 * 7. Limitation of Liability
 *
 *    Under no circumstances and under no legal theory, whether tort (including
 *    negligence), contract, or otherwise, shall any Contributor, or anyone who
 *    distributes Covered Software as permitted above, be liable to You for any
 *    direct, indirect, special, incidental, or consequential damages of any
 *    character including, without limitation, damages for lost profits, loss of
 *    goodwill, work stoppage, computer failure or malfunction, or any and all
 *    other commercial damages or losses, even if such party shall have been
 *    informed of the possibility of such damages. This limitation of liability
 *    shall not apply to liability for death or personal injury resulting from such
 *    party’s negligence to the extent applicable law prohibits such limitation.
 *    Some jurisdictions do not allow the exclusion or limitation of incidental or
 *    consequential damages, so this exclusion and limitation may not apply to You.
 *
 * 8. Litigation
 *
 *    Any litigation relating to this License may be brought only in the courts of
 *    a jurisdiction where the defendant maintains its principal place of business
 *    and such litigation shall be governed by laws of that jurisdiction, without
 *    reference to its conflict-of-law provisions. Nothing in this Section shall
 *    prevent a party’s ability to bring cross-claims or counter-claims.
 *
 * 9. Miscellaneous
 *
 *    This License represents the complete agreement concerning the subject matter
 *    hereof. If any provision of this License is held to be unenforceable, such
 *    provision shall be reformed only to the extent necessary to make it
 *    enforceable. Any law or regulation which provides that the language of a
 *    contract shall be construed against the drafter shall not be used to construe
 *    this License against a Contributor.
 *
 *
 * 10. Versions of the License
 *
 * 10.1. New Versions
 *
 *       Mozilla Foundation is the license steward. Except as provided in Section
 *       10.3, no one other than the license steward has the right to modify or
 *       publish new versions of this License. Each version will be given a
 *       distinguishing version number.
 *
 * 10.2. Effect of New Versions
 *
 *       You may distribute the Covered Software under the terms of the version of
 *       the License under which You originally received the Covered Software, or
 *       under the terms of any subsequent version published by the license
 *       steward.
 *
 * 10.3. Modified Versions
 *
 *       If you create software not governed by this License, and you want to
 *       create a new license for such software, you may create and use a modified
 *       version of this License if you rename the license and remove any
 *       references to the name of the license steward (except to note that such
 *       modified license differs from this License).
 *
 * 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses
 *       If You choose to distribute Source Code Form that is Incompatible With
 *       Secondary Licenses under the terms of this version of the License, the
 *       notice described in Exhibit B of this License must be attached.
 *
 * Exhibit A - Source Code Form License Notice
 *
 *       This Source Code Form is subject to the
 *       terms of the Mozilla Public License, v.
 *       2.0. If a copy of the MPL was not
 *       distributed with this file, You can
 *       obtain one at
 *       http://mozilla.org/MPL/2.0/.
 *
 * If it is not possible or desirable to put the notice in a particular file, then
 * You may include the notice in a location (such as a LICENSE file in a relevant
 * directory) where a recipient would be likely to look for such a notice.
 *
 * You may add additional accurate notices of copyright ownership.
 *
 * Exhibit B - “Incompatible With Secondary Licenses” Notice
 *
 *       This Source Code Form is “Incompatible
 *       With Secondary Licenses”, as defined by
 *       the Mozilla Public License, v. 2.0.
 */
package com.chiorichan.configuration;

import java.awt.Color;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.Validate;

/**
 * A type of {@link ConfigurationSection} that is stored in memory.
 */
public class MemorySection implements ConfigurationSection
{
	protected final Map<String, Object> map = new LinkedHashMap<String, Object>();
	private final Configuration root;
	private final ConfigurationSection parent;
	private final String path;
	private final String fullPath;
	
	/**
	 * Creates an empty MemorySection for use as a root {@link Configuration} section.
	 * <p />
	 * Note that calling this without being yourself a {@link Configuration} will throw an exception!
	 * 
	 * @throws IllegalStateException
	 *            Thrown if this is not a {@link Configuration} root.
	 */
	protected MemorySection()
	{
		if ( !( this instanceof Configuration ) )
		{
			throw new IllegalStateException( "Cannot construct a root MemorySection when not a Configuration" );
		}
		
		this.path = "";
		this.fullPath = "";
		this.parent = null;
		this.root = (Configuration) this;
	}
	
	/**
	 * Creates an empty MemorySection with the specified parent and path.
	 * 
	 * @param parent
	 *           Parent section that contains this own section.
	 * @param path
	 *           Path that you may access this section from via the root {@link Configuration}.
	 * @throws IllegalArgumentException
	 *            Thrown is parent or path is null, or if parent contains no root Configuration.
	 */
	protected MemorySection(ConfigurationSection parent, String path)
	{
		Validate.notNull( parent, "Parent cannot be null" );
		Validate.notNull( path, "Path cannot be null" );
		
		this.path = path;
		this.parent = parent;
		this.root = parent.getRoot();
		
		Validate.notNull( root, "Path cannot be orphaned" );
		
		this.fullPath = createPath( parent, path );
	}
	
	public Set<String> getKeys( boolean deep )
	{
		Set<String> result = new LinkedHashSet<String>();
		
		Configuration root = getRoot();
		if ( root != null && root.options().copyDefaults() )
		{
			ConfigurationSection defaults = getDefaultSection();
			
			if ( defaults != null )
			{
				result.addAll( defaults.getKeys( deep ) );
			}
		}
		
		mapChildrenKeys( result, this, deep );
		
		return result;
	}
	
	public Map<String, Object> getValues( boolean deep )
	{
		Map<String, Object> result = new LinkedHashMap<String, Object>();
		
		Configuration root = getRoot();
		if ( root != null && root.options().copyDefaults() )
		{
			ConfigurationSection defaults = getDefaultSection();
			
			if ( defaults != null )
			{
				result.putAll( defaults.getValues( deep ) );
			}
		}
		
		mapChildrenValues( result, this, deep );
		
		return result;
	}
	
	public boolean contains( String path )
	{
		return get( path ) != null;
	}
	
	public boolean isSet( String path )
	{
		Configuration root = getRoot();
		if ( root == null )
		{
			return false;
		}
		if ( root.options().copyDefaults() )
		{
			return contains( path );
		}
		return get( path, null ) != null;
	}
	
	public String getCurrentPath()
	{
		return fullPath;
	}
	
	public String getName()
	{
		return path;
	}
	
	public Configuration getRoot()
	{
		return root;
	}
	
	public ConfigurationSection getParent()
	{
		return parent;
	}
	
	public void addDefault( String path, Object value )
	{
		Validate.notNull( path, "Path cannot be null" );
		
		Configuration root = getRoot();
		if ( root == null )
		{
			throw new IllegalStateException( "Cannot add default without root" );
		}
		if ( root == this )
		{
			throw new UnsupportedOperationException( "Unsupported addDefault(String, Object) implementation" );
		}
		root.addDefault( createPath( this, path ), value );
	}
	
	public ConfigurationSection getDefaultSection()
	{
		Configuration root = getRoot();
		Configuration defaults = root == null ? null : root.getDefaults();
		
		if ( defaults != null )
		{
			if ( defaults.isConfigurationSection( getCurrentPath() ) )
			{
				return defaults.getConfigurationSection( getCurrentPath() );
			}
		}
		
		return null;
	}
	
	public void set( String path, Object value )
	{
		Validate.notEmpty( path, "Cannot set to an empty path" );
		
		Configuration root = getRoot();
		if ( root == null )
		{
			throw new IllegalStateException( "Cannot use section without a root" );
		}
		
		final char separator = root.options().pathSeparator();
		// i1 is the leading (higher) index
		// i2 is the trailing (lower) index
		int i1 = -1, i2;
		ConfigurationSection section = this;
		while ( ( i1 = path.indexOf( separator, i2 = i1 + 1 ) ) != -1 )
		{
			String node = path.substring( i2, i1 );
			ConfigurationSection subSection = section.getConfigurationSection( node );
			if ( subSection == null )
			{
				section = section.createSection( node );
			}
			else
			{
				section = subSection;
			}
		}
		
		String key = path.substring( i2 );
		if ( section == this )
		{
			if ( value == null )
			{
				map.remove( key );
			}
			else
			{
				map.put( key, value );
			}
		}
		else
		{
			section.set( key, value );
		}
	}
	
	public Object get( String path )
	{
		return get( path, getDefault( path ) );
	}
	
	public Object get( String path, Object def )
	{
		Validate.notNull( path, "Path cannot be null" );
		
		if ( path.length() == 0 )
		{
			return this;
		}
		
		Configuration root = getRoot();
		if ( root == null )
		{
			throw new IllegalStateException( "Cannot access section without a root" );
		}
		
		final char separator = root.options().pathSeparator();
		// i1 is the leading (higher) index
		// i2 is the trailing (lower) index
		int i1 = -1, i2;
		ConfigurationSection section = this;
		while ( ( i1 = path.indexOf( separator, i2 = i1 + 1 ) ) != -1 )
		{
			section = section.getConfigurationSection( path.substring( i2, i1 ) );
			if ( section == null )
			{
				return def;
			}
		}
		
		String key = path.substring( i2 );
		if ( section == this )
		{
			Object result = map.get( key );
			return ( result == null ) ? def : result;
		}
		return section.get( key, def );
	}
	
	public ConfigurationSection createSection( String path )
	{
		Validate.notEmpty( path, "Cannot create section at empty path" );
		Configuration root = getRoot();
		if ( root == null )
		{
			throw new IllegalStateException( "Cannot create section without a root" );
		}
		
		final char separator = root.options().pathSeparator();
		// i1 is the leading (higher) index
		// i2 is the trailing (lower) index
		int i1 = -1, i2;
		ConfigurationSection section = this;
		while ( ( i1 = path.indexOf( separator, i2 = i1 + 1 ) ) != -1 )
		{
			String node = path.substring( i2, i1 );
			ConfigurationSection subSection = section.getConfigurationSection( node );
			if ( subSection == null )
			{
				section = section.createSection( node );
			}
			else
			{
				section = subSection;
			}
		}
		
		String key = path.substring( i2 );
		if ( section == this )
		{
			ConfigurationSection result = new MemorySection( this, key );
			map.put( key, result );
			return result;
		}
		return section.createSection( key );
	}
	
	public ConfigurationSection createSection( String path, Map<?, ?> map )
	{
		ConfigurationSection section = createSection( path );
		
		for ( Map.Entry<?, ?> entry : map.entrySet() )
		{
			if ( entry.getValue() instanceof Map )
			{
				section.createSection( entry.getKey().toString(), (Map<?, ?>) entry.getValue() );
			}
			else
			{
				section.set( entry.getKey().toString(), entry.getValue() );
			}
		}
		
		return section;
	}
	
	// Primitives
	public String getString( String path )
	{
		Object def = getDefault( path );
		return getString( path, def != null ? def.toString() : null );
	}
	
	public String getString( String path, String def )
	{
		Object val = get( path, def );
		return ( val != null ) ? val.toString() : def;
	}
	
	public boolean isString( String path )
	{
		Object val = get( path );
		return val instanceof String;
	}
	
	public int getInt( String path )
	{
		Object def = getDefault( path );
		return getInt( path, ( def instanceof Number ) ? toInt( def ) : 0 );
	}
	
	public int getInt( String path, int def )
	{
		Object val = get( path, def );
		return ( val instanceof Integer ) ? toInt( val ) : def;
	}

	public boolean isInt( String path )
	{
		Object val = get( path );
		return val instanceof Integer;
	}
	
	public boolean getBoolean( String path )
	{
		Object def = getDefault( path );
		return getBoolean( path, ( def instanceof Boolean ) ? (Boolean) def : false );
	}
	
	public boolean getBoolean( String path, boolean def )
	{
		Object val = get( path, def );
		return ( val instanceof Boolean ) ? (Boolean) val : def;
	}
	
	public boolean isBoolean( String path )
	{
		Object val = get( path );
		return val instanceof Boolean;
	}
	
	public double getDouble( String path )
	{
		Object def = getDefault( path );
		return getDouble( path, ( def instanceof Number ) ? toDouble( def ) : 0 );
	}

	public double getDouble( String path, double def )
	{
		Object val = get( path, def );
		return ( val instanceof Number ) ? toDouble( val ) : def;
	}
	
	public boolean isDouble( String path )
	{
		Object val = get( path );
		return val instanceof Double;
	}
	
	public long getLong( String path )
	{
		Object def = getDefault( path );
		return getLong( path, ( def instanceof Number ) ? toLong( def ) : 0 );
	}

	public long getLong( String path, long def )
	{
		Object val = get( path, def );
		return ( val instanceof Number ) ? toLong( val ) : def;
	}
	
	public boolean isLong( String path )
	{
		Object val = get( path );
		return val instanceof Long;
	}
	
	// Java
	public List<?> getList( String path )
	{
		Object def = getDefault( path );
		return getList( path, ( def instanceof List ) ? (List<?>) def : null );
	}
	
	public List<?> getList( String path, List<?> def )
	{
		Object val = get( path, def );
		return (List<?>) ( ( val instanceof List ) ? val : def );
	}
	
	public boolean isList( String path )
	{
		Object val = get( path );
		return val instanceof List;
	}
	
	public List<String> getStringList( String path, List<String> def )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return def;
		}
		
		List<String> result = new ArrayList<String>();
		
		for ( Object object : list )
		{
			if ( ( object instanceof String ) || ( isPrimitiveWrapper( object ) ) )
			{
				result.add( String.valueOf( object ) );
			}
		}
		
		return result;
	}
	
	public List<String> getStringList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<String>( 0 );
		}
		
		List<String> result = new ArrayList<String>();
		
		for ( Object object : list )
		{
			if ( ( object instanceof String ) || ( isPrimitiveWrapper( object ) ) )
			{
				result.add( String.valueOf( object ) );
			}
		}
		
		return result;
	}
	
	public List<Integer> getIntegerList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Integer>( 0 );
		}
		
		List<Integer> result = new ArrayList<Integer>();
		
		for ( Object object : list )
		{
			if ( object instanceof Integer )
			{
				result.add( (Integer) object );
			}
			else if ( object instanceof String )
			{
				try
				{
					result.add( Integer.valueOf( (String) object ) );
				}
				catch ( Exception ex )
				{}
			}
			else if ( object instanceof Character )
			{
				result.add( (int) ( (Character) object ).charValue() );
			}
			else if ( object instanceof Number )
			{
				result.add( ( (Number) object ).intValue() );
			}
		}
		
		return result;
	}
	
	public List<Boolean> getBooleanList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Boolean>( 0 );
		}
		
		List<Boolean> result = new ArrayList<Boolean>();
		
		for ( Object object : list )
		{
			if ( object instanceof Boolean )
			{
				result.add( (Boolean) object );
			}
			else if ( object instanceof String )
			{
				if ( Boolean.TRUE.toString().equals( object ) )
				{
					result.add( true );
				}
				else if ( Boolean.FALSE.toString().equals( object ) )
				{
					result.add( false );
				}
			}
		}
		
		return result;
	}
	
	public List<Double> getDoubleList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Double>( 0 );
		}
		
		List<Double> result = new ArrayList<Double>();
		
		for ( Object object : list )
		{
			if ( object instanceof Double )
			{
				result.add( (Double) object );
			}
			else if ( object instanceof String )
			{
				try
				{
					result.add( Double.valueOf( (String) object ) );
				}
				catch ( Exception ex )
				{}
			}
			else if ( object instanceof Character )
			{
				result.add( (double) ( (Character) object ).charValue() );
			}
			else if ( object instanceof Number )
			{
				result.add( ( (Number) object ).doubleValue() );
			}
		}
		
		return result;
	}
	
	public List<Float> getFloatList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Float>( 0 );
		}
		
		List<Float> result = new ArrayList<Float>();
		
		for ( Object object : list )
		{
			if ( object instanceof Float )
			{
				result.add( (Float) object );
			}
			else if ( object instanceof String )
			{
				try
				{
					result.add( Float.valueOf( (String) object ) );
				}
				catch ( Exception ex )
				{}
			}
			else if ( object instanceof Character )
			{
				result.add( (float) ( (Character) object ).charValue() );
			}
			else if ( object instanceof Number )
			{
				result.add( ( (Number) object ).floatValue() );
			}
		}
		
		return result;
	}
	
	public List<Long> getLongList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Long>( 0 );
		}
		
		List<Long> result = new ArrayList<Long>();
		
		for ( Object object : list )
		{
			if ( object instanceof Long )
			{
				result.add( (Long) object );
			}
			else if ( object instanceof String )
			{
				try
				{
					result.add( Long.valueOf( (String) object ) );
				}
				catch ( Exception ex )
				{}
			}
			else if ( object instanceof Character )
			{
				result.add( (long) ( (Character) object ).charValue() );
			}
			else if ( object instanceof Number )
			{
				result.add( ( (Number) object ).longValue() );
			}
		}
		
		return result;
	}
	
	public List<Byte> getByteList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Byte>( 0 );
		}
		
		List<Byte> result = new ArrayList<Byte>();
		
		for ( Object object : list )
		{
			if ( object instanceof Byte )
			{
				result.add( (Byte) object );
			}
			else if ( object instanceof String )
			{
				try
				{
					result.add( Byte.valueOf( (String) object ) );
				}
				catch ( Exception ex )
				{}
			}
			else if ( object instanceof Character )
			{
				result.add( (byte) ( (Character) object ).charValue() );
			}
			else if ( object instanceof Number )
			{
				result.add( ( (Number) object ).byteValue() );
			}
		}
		
		return result;
	}
	
	public List<Character> getCharacterList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Character>( 0 );
		}
		
		List<Character> result = new ArrayList<Character>();
		
		for ( Object object : list )
		{
			if ( object instanceof Character )
			{
				result.add( (Character) object );
			}
			else if ( object instanceof String )
			{
				String str = (String) object;
				
				if ( str.length() == 1 )
				{
					result.add( str.charAt( 0 ) );
				}
			}
			else if ( object instanceof Number )
			{
				result.add( (char) ( (Number) object ).intValue() );
			}
		}
		
		return result;
	}
	
	public List<Short> getShortList( String path )
	{
		List<?> list = getList( path );
		
		if ( list == null )
		{
			return new ArrayList<Short>( 0 );
		}
		
		List<Short> result = new ArrayList<Short>();
		
		for ( Object object : list )
		{
			if ( object instanceof Short )
			{
				result.add( (Short) object );
			}
			else if ( object instanceof String )
			{
				try
				{
					result.add( Short.valueOf( (String) object ) );
				}
				catch ( Exception ex )
				{}
			}
			else if ( object instanceof Character )
			{
				result.add( (short) ( (Character) object ).charValue() );
			}
			else if ( object instanceof Number )
			{
				result.add( ( (Number) object ).shortValue() );
			}
		}
		
		return result;
	}
	
	public List<Map<?, ?>> getMapList( String path )
	{
		List<?> list = getList( path );
		List<Map<?, ?>> result = new ArrayList<Map<?, ?>>();
		
		if ( list == null )
		{
			return result;
		}
		
		for ( Object object : list )
		{
			if ( object instanceof Map )
			{
				result.add( (Map<?, ?>) object );
			}
		}
		
		return result;
	}
	
	public Color getColor( String path )
	{
		Object def = getDefault( path );
		return getColor( path, ( def instanceof Color ) ? (Color) def : null );
	}
	
	public Color getColor( String path, Color def )
	{
		Object val = get( path, def );
		return ( val instanceof Color ) ? (Color) val : def;
	}
	
	public boolean isColor( String path )
	{
		Object val = get( path );
		return val instanceof Color;
	}
	
	public ConfigurationSection getConfigurationSection( String path )
	{
		Object val = get( path, null );
		if ( val != null )
		{
			return ( val instanceof ConfigurationSection ) ? (ConfigurationSection) val : null;
		}
		
		val = get( path, getDefault( path ) );
		return ( val instanceof ConfigurationSection ) ? createSection( path ) : null;
	}
	
	public boolean isConfigurationSection( String path )
	{
		Object val = get( path );
		return val instanceof ConfigurationSection;
	}
	
	protected boolean isPrimitiveWrapper( Object input )
	{
		return input instanceof Integer || input instanceof Boolean || input instanceof Character || input instanceof Byte || input instanceof Short || input instanceof Double || input instanceof Long || input instanceof Float;
	}
	
	protected Object getDefault( String path )
	{
		Validate.notNull( path, "Path cannot be null" );
		
		Configuration root = getRoot();
		Configuration defaults = root == null ? null : root.getDefaults();
		return ( defaults == null ) ? null : defaults.get( createPath( this, path ) );
	}
	
	protected void mapChildrenKeys( Set<String> output, ConfigurationSection section, boolean deep )
	{
		if ( section instanceof MemorySection )
		{
			MemorySection sec = (MemorySection) section;
			
			for ( Map.Entry<String, Object> entry : sec.map.entrySet() )
			{
				output.add( createPath( section, entry.getKey(), this ) );
				
				if ( ( deep ) && ( entry.getValue() instanceof ConfigurationSection ) )
				{
					ConfigurationSection subsection = (ConfigurationSection) entry.getValue();
					mapChildrenKeys( output, subsection, deep );
				}
			}
		}
		else
		{
			Set<String> keys = section.getKeys( deep );
			
			for ( String key : keys )
			{
				output.add( createPath( section, key, this ) );
			}
		}
	}
	
	protected void mapChildrenValues( Map<String, Object> output, ConfigurationSection section, boolean deep )
	{
		if ( section instanceof MemorySection )
		{
			MemorySection sec = (MemorySection) section;
			
			for ( Map.Entry<String, Object> entry : sec.map.entrySet() )
			{
				output.put( createPath( section, entry.getKey(), this ), entry.getValue() );
				
				if ( entry.getValue() instanceof ConfigurationSection )
				{
					if ( deep )
					{
						mapChildrenValues( output, (ConfigurationSection) entry.getValue(), deep );
					}
				}
			}
		}
		else
		{
			Map<String, Object> values = section.getValues( deep );
			
			for ( Map.Entry<String, Object> entry : values.entrySet() )
			{
				output.put( createPath( section, entry.getKey(), this ), entry.getValue() );
			}
		}
	}
	
	/**
	 * Creates a full path to the given {@link ConfigurationSection} from its root {@link Configuration}.
	 * <p />
	 * You may use this method for any given {@link ConfigurationSection}, not only {@link MemorySection}.
	 * 
	 * @param section
	 *           Section to create a path for.
	 * @param key
	 *           Name of the specified section.
	 * @return Full path of the section from its root.
	 */
	public static String createPath( ConfigurationSection section, String key )
	{
		return createPath( section, key, ( section == null ) ? null : section.getRoot() );
	}
	
	/**
	 * Creates a relative path to the given {@link ConfigurationSection} from the given relative section.
	 * <p />
	 * You may use this method for any given {@link ConfigurationSection}, not only {@link MemorySection}.
	 * 
	 * @param section
	 *           Section to create a path for.
	 * @param key
	 *           Name of the specified section.
	 * @param relativeTo
	 *           Section to create the path relative to.
	 * @return Full path of the section from its root.
	 */
	public static String createPath( ConfigurationSection section, String key, ConfigurationSection relativeTo )
	{
		Validate.notNull( section, "Cannot create path without a section" );
		Configuration root = section.getRoot();
		if ( root == null )
		{
			throw new IllegalStateException( "Cannot create path without a root" );
		}
		char separator = root.options().pathSeparator();
		
		StringBuilder builder = new StringBuilder();
		if ( section != null )
		{
			for ( ConfigurationSection parent = section; ( parent != null ) && ( parent != relativeTo ); parent = parent.getParent() )
			{
				if ( builder.length() > 0 )
				{
					builder.insert( 0, separator );
				}
				
				builder.insert( 0, parent.getName() );
			}
		}
		
		if ( ( key != null ) && ( key.length() > 0 ) )
		{
			if ( builder.length() > 0 )
			{
				builder.append( separator );
			}
			
			builder.append( key );
		}
		
		return builder.toString();
	}
	
	@Override
	public String toString()
	{
		Configuration root = getRoot();
		return new StringBuilder().append( getClass().getSimpleName() ).append( "[path='" ).append( getCurrentPath() ).append( "', root='" ).append( root == null ? null : root.getClass().getSimpleName() ).append( "']" ).toString();
	}
	
	private int toInt( Object val )
	{
		if ( val instanceof Integer )
			return (int) val;
		
		try
		{
			return Integer.parseInt( (String) val );
		}
		catch ( Exception e )
		{
			e.printStackTrace();
			return 0;
		}
	}
	
	private double toDouble( Object def )
	{
		if ( def instanceof Double )
			return (double) def;
		
		try
		{
			return Double.parseDouble( (String) def );
		}
		catch ( Exception e )
		{
			e.printStackTrace();
			return 0;
		}
	}
	
	private long toLong( Object def )
	{
		try
		{
			return Long.parseLong( (String) def );
		}
		catch ( Exception e )
		{
			return 0;
		}
	}
}
