/**
 * Mozilla Public License, version 2.0
 *
 * 1. Definitions
 *
 * 1.1. “Contributor”
 *
 *      means each individual or legal entity that creates, contributes to the
 *      creation of, or owns Covered Software.
 *
 * 1.2. “Contributor Version”
 *
 *      means the combination of the Contributions of others (if any) used by a
 *      Contributor and that particular Contributor’s Contribution.
 *
 * 1.3. “Contribution”
 *
 *      means Covered Software of a particular Contributor.
 *
 * 1.4. “Covered Software”
 *
 *      means Source Code Form to which the initial Contributor has attached the
 *      notice in Exhibit A, the Executable Form of such Source Code Form, and
 *      Modifications of such Source Code Form, in each case including portions
 *      thereof.
 *
 * 1.5. “Incompatible With Secondary Licenses”
 *      means
 *
 *      a. that the initial Contributor has attached the notice described in
 *         Exhibit B to the Covered Software; or
 *
 *      b. that the Covered Software was made available under the terms of version
 *         1.1 or earlier of the License, but not also under the terms of a
 *         Secondary License.
 *
 * 1.6. “Executable Form”
 *
 *      means any form of the work other than Source Code Form.
 *
 * 1.7. “Larger Work”
 *
 *      means a work that combines Covered Software with other material, in a separate
 *      file or files, that is not Covered Software.
 *
 * 1.8. “License”
 *
 *      means this document.
 *
 * 1.9. “Licensable”
 *
 *      means having the right to grant, to the maximum extent possible, whether at the
 *      time of the initial grant or subsequently, any and all of the rights conveyed by
 *      this License.
 *
 * 1.10. “Modifications”
 *
 *      means any of the following:
 *
 *      a. any file in Source Code Form that results from an addition to, deletion
 *         from, or modification of the contents of Covered Software; or
 *
 *      b. any new file in Source Code Form that contains any Covered Software.
 *
 * 1.11. “Patent Claims” of a Contributor
 *
 *       means any patent claim(s), including without limitation, method, process,
 *       and apparatus claims, in any patent Licensable by such Contributor that
 *       would be infringed, but for the grant of the License, by the making,
 *       using, selling, offering for sale, having made, import, or transfer of
 *       either its Contributions or its Contributor Version.
 *
 * 1.12. “Secondary License”
 *
 *       means either the GNU General Public License, Version 2.0, the GNU Lesser
 *       General Public License, Version 2.1, the GNU Affero General Public
 *       License, Version 3.0, or any later versions of those licenses.
 *
 * 1.13. “Source Code Form”
 *
 *       means the form of the work preferred for making modifications.
 *
 * 1.14. “You” (or “Your”)
 *
 *       means an individual or a legal entity exercising rights under this
 *       License. For legal entities, “You” includes any entity that controls, is
 *       controlled by, or is under common control with You. For purposes of this
 *       definition, “control” means (a) the power, direct or indirect, to cause
 *       the direction or management of such entity, whether by contract or
 *       otherwise, or (b) ownership of more than fifty percent (50%) of the
 *       outstanding shares or beneficial ownership of such entity.
 *
 *
 * 2. License Grants and Conditions
 *
 * 2.1. Grants
 *
 *      Each Contributor hereby grants You a world-wide, royalty-free,
 *      non-exclusive license:
 *
 *      a. under intellectual property rights (other than patent or trademark)
 *         Licensable by such Contributor to use, reproduce, make available,
 *         modify, display, perform, distribute, and otherwise exploit its
 *         Contributions, either on an unmodified basis, with Modifications, or as
 *         part of a Larger Work; and
 *
 *      b. under Patent Claims of such Contributor to make, use, sell, offer for
 *         sale, have made, import, and otherwise transfer either its Contributions
 *         or its Contributor Version.
 *
 * 2.2. Effective Date
 *
 *      The licenses granted in Section 2.1 with respect to any Contribution become
 *      effective for each Contribution on the date the Contributor first distributes
 *      such Contribution.
 *
 * 2.3. Limitations on Grant Scope
 *
 *      The licenses granted in this Section 2 are the only rights granted under this
 *      License. No additional rights or licenses will be implied from the distribution
 *      or licensing of Covered Software under this License. Notwithstanding Section
 *      2.1(b) above, no patent license is granted by a Contributor:
 *
 *      a. for any code that a Contributor has removed from Covered Software; or
 *
 *      b. for infringements caused by: (i) Your and any other third party’s
 *         modifications of Covered Software, or (ii) the combination of its
 *         Contributions with other software (except as part of its Contributor
 *         Version); or
 *
 *      c. under Patent Claims infringed by Covered Software in the absence of its
 *         Contributions.
 *
 *      This License does not grant any rights in the trademarks, service marks, or
 *      logos of any Contributor (except as may be necessary to comply with the
 *      notice requirements in Section 3.4).
 *
 * 2.4. Subsequent Licenses
 *
 *      No Contributor makes additional grants as a result of Your choice to
 *      distribute the Covered Software under a subsequent version of this License
 *      (see Section 10.2) or under the terms of a Secondary License (if permitted
 *      under the terms of Section 3.3).
 *
 * 2.5. Representation
 *
 *      Each Contributor represents that the Contributor believes its Contributions
 *      are its original creation(s) or it has sufficient rights to grant the
 *      rights to its Contributions conveyed by this License.
 *
 * 2.6. Fair Use
 *
 *      This License is not intended to limit any rights You have under applicable
 *      copyright doctrines of fair use, fair dealing, or other equivalents.
 *
 * 2.7. Conditions
 *
 *      Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in
 *      Section 2.1.
 *
 *
 * 3. Responsibilities
 *
 * 3.1. Distribution of Source Form
 *
 *      All distribution of Covered Software in Source Code Form, including any
 *      Modifications that You create or to which You contribute, must be under the
 *      terms of this License. You must inform recipients that the Source Code Form
 *      of the Covered Software is governed by the terms of this License, and how
 *      they can obtain a copy of this License. You may not attempt to alter or
 *      restrict the recipients’ rights in the Source Code Form.
 *
 * 3.2. Distribution of Executable Form
 *
 *      If You distribute Covered Software in Executable Form then:
 *
 *      a. such Covered Software must also be made available in Source Code Form,
 *         as described in Section 3.1, and You must inform recipients of the
 *         Executable Form how they can obtain a copy of such Source Code Form by
 *         reasonable means in a timely manner, at a charge no more than the cost
 *         of distribution to the recipient; and
 *
 *      b. You may distribute such Executable Form under the terms of this License,
 *         or sublicense it under different terms, provided that the license for
 *         the Executable Form does not attempt to limit or alter the recipients’
 *         rights in the Source Code Form under this License.
 *
 * 3.3. Distribution of a Larger Work
 *
 *      You may create and distribute a Larger Work under terms of Your choice,
 *      provided that You also comply with the requirements of this License for the
 *      Covered Software. If the Larger Work is a combination of Covered Software
 *      with a work governed by one or more Secondary Licenses, and the Covered
 *      Software is not Incompatible With Secondary Licenses, this License permits
 *      You to additionally distribute such Covered Software under the terms of
 *      such Secondary License(s), so that the recipient of the Larger Work may, at
 *      their option, further distribute the Covered Software under the terms of
 *      either this License or such Secondary License(s).
 *
 * 3.4. Notices
 *
 *      You may not remove or alter the substance of any license notices (including
 *      copyright notices, patent notices, disclaimers of warranty, or limitations
 *      of liability) contained within the Source Code Form of the Covered
 *      Software, except that You may alter any license notices to the extent
 *      required to remedy known factual inaccuracies.
 *
 * 3.5. Application of Additional Terms
 *
 *      You may choose to offer, and to charge a fee for, warranty, support,
 *      indemnity or liability obligations to one or more recipients of Covered
 *      Software. However, You may do so only on Your own behalf, and not on behalf
 *      of any Contributor. You must make it absolutely clear that any such
 *      warranty, support, indemnity, or liability obligation is offered by You
 *      alone, and You hereby agree to indemnify every Contributor for any
 *      liability incurred by such Contributor as a result of warranty, support,
 *      indemnity or liability terms You offer. You may include additional
 *      disclaimers of warranty and limitations of liability specific to any
 *      jurisdiction.
 *
 * 4. Inability to Comply Due to Statute or Regulation
 *
 *    If it is impossible for You to comply with any of the terms of this License
 *    with respect to some or all of the Covered Software due to statute, judicial
 *    order, or regulation then You must: (a) comply with the terms of this License
 *    to the maximum extent possible; and (b) describe the limitations and the code
 *    they affect. Such description must be placed in a text file included with all
 *    distributions of the Covered Software under this License. Except to the
 *    extent prohibited by statute or regulation, such description must be
 *    sufficiently detailed for a recipient of ordinary skill to be able to
 *    understand it.
 *
 * 5. Termination
 *
 * 5.1. The rights granted under this License will terminate automatically if You
 *      fail to comply with any of its terms. However, if You become compliant,
 *      then the rights granted under this License from a particular Contributor
 *      are reinstated (a) provisionally, unless and until such Contributor
 *      explicitly and finally terminates Your grants, and (b) on an ongoing basis,
 *      if such Contributor fails to notify You of the non-compliance by some
 *      reasonable means prior to 60 days after You have come back into compliance.
 *      Moreover, Your grants from a particular Contributor are reinstated on an
 *      ongoing basis if such Contributor notifies You of the non-compliance by
 *      some reasonable means, this is the first time You have received notice of
 *      non-compliance with this License from such Contributor, and You become
 *      compliant prior to 30 days after Your receipt of the notice.
 *
 * 5.2. If You initiate litigation against any entity by asserting a patent
 *      infringement claim (excluding declaratory judgment actions, counter-claims,
 *      and cross-claims) alleging that a Contributor Version directly or
 *      indirectly infringes any patent, then the rights granted to You by any and
 *      all Contributors for the Covered Software under Section 2.1 of this License
 *      shall terminate.
 *
 * 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user
 *      license agreements (excluding distributors and resellers) which have been
 *      validly granted by You or Your distributors under this License prior to
 *      termination shall survive termination.
 *
 * 6. Disclaimer of Warranty
 *
 *    Covered Software is provided under this License on an “as is” basis, without
 *    warranty of any kind, either expressed, implied, or statutory, including,
 *    without limitation, warranties that the Covered Software is free of defects,
 *    merchantable, fit for a particular purpose or non-infringing. The entire
 *    risk as to the quality and performance of the Covered Software is with You.
 *    Should any Covered Software prove defective in any respect, You (not any
 *    Contributor) assume the cost of any necessary servicing, repair, or
 *    correction. This disclaimer of warranty constitutes an essential part of this
 *    License. No use of  any Covered Software is authorized under this License
 *    except under this disclaimer.
 *
 * 7. Limitation of Liability
 *
 *    Under no circumstances and under no legal theory, whether tort (including
 *    negligence), contract, or otherwise, shall any Contributor, or anyone who
 *    distributes Covered Software as permitted above, be liable to You for any
 *    direct, indirect, special, incidental, or consequential damages of any
 *    character including, without limitation, damages for lost profits, loss of
 *    goodwill, work stoppage, computer failure or malfunction, or any and all
 *    other commercial damages or losses, even if such party shall have been
 *    informed of the possibility of such damages. This limitation of liability
 *    shall not apply to liability for death or personal injury resulting from such
 *    party’s negligence to the extent applicable law prohibits such limitation.
 *    Some jurisdictions do not allow the exclusion or limitation of incidental or
 *    consequential damages, so this exclusion and limitation may not apply to You.
 *
 * 8. Litigation
 *
 *    Any litigation relating to this License may be brought only in the courts of
 *    a jurisdiction where the defendant maintains its principal place of business
 *    and such litigation shall be governed by laws of that jurisdiction, without
 *    reference to its conflict-of-law provisions. Nothing in this Section shall
 *    prevent a party’s ability to bring cross-claims or counter-claims.
 *
 * 9. Miscellaneous
 *
 *    This License represents the complete agreement concerning the subject matter
 *    hereof. If any provision of this License is held to be unenforceable, such
 *    provision shall be reformed only to the extent necessary to make it
 *    enforceable. Any law or regulation which provides that the language of a
 *    contract shall be construed against the drafter shall not be used to construe
 *    this License against a Contributor.
 *
 *
 * 10. Versions of the License
 *
 * 10.1. New Versions
 *
 *       Mozilla Foundation is the license steward. Except as provided in Section
 *       10.3, no one other than the license steward has the right to modify or
 *       publish new versions of this License. Each version will be given a
 *       distinguishing version number.
 *
 * 10.2. Effect of New Versions
 *
 *       You may distribute the Covered Software under the terms of the version of
 *       the License under which You originally received the Covered Software, or
 *       under the terms of any subsequent version published by the license
 *       steward.
 *
 * 10.3. Modified Versions
 *
 *       If you create software not governed by this License, and you want to
 *       create a new license for such software, you may create and use a modified
 *       version of this License if you rename the license and remove any
 *       references to the name of the license steward (except to note that such
 *       modified license differs from this License).
 *
 * 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses
 *       If You choose to distribute Source Code Form that is Incompatible With
 *       Secondary Licenses under the terms of this version of the License, the
 *       notice described in Exhibit B of this License must be attached.
 *
 * Exhibit A - Source Code Form License Notice
 *
 *       This Source Code Form is subject to the
 *       terms of the Mozilla Public License, v.
 *       2.0. If a copy of the MPL was not
 *       distributed with this file, You can
 *       obtain one at
 *       http://mozilla.org/MPL/2.0/.
 *
 * If it is not possible or desirable to put the notice in a particular file, then
 * You may include the notice in a location (such as a LICENSE file in a relevant
 * directory) where a recipient would be likely to look for such a notice.
 *
 * You may add additional accurate notices of copyright ownership.
 *
 * Exhibit B - “Incompatible With Secondary Licenses” Notice
 *
 *       This Source Code Form is “Incompatible
 *       With Secondary Licenses”, as defined by
 *       the Mozilla Public License, v. 2.0.
 */
package com.chiorichan.http;

import groovy.lang.Binding;

import java.io.File;
import java.io.IOException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import com.chiorichan.ChatColor;
import com.chiorichan.Loader;
import com.chiorichan.account.bases.Account;
import com.chiorichan.account.bases.Sentient;
import com.chiorichan.account.bases.SentientHandler;
import com.chiorichan.account.helpers.LoginException;
import com.chiorichan.database.DatabaseEngine;
import com.chiorichan.factory.BindingProvider;
import com.chiorichan.factory.CodeEvalFactory;
import com.chiorichan.framework.ConfigurationManagerWrapper;
import com.chiorichan.framework.Site;
import com.chiorichan.util.Common;
import com.chiorichan.util.StringUtil;
import com.google.common.collect.Lists;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

/**
 * This class is used to carry data that is to be persistent from request to request.
 * If you need to sync data across requests then we recommend using Session Vars for Security.
 * 
 * @author Chiori Greene
 * @copyright Greenetree LLC
 */
public class PersistentSession implements SentientHandler, BindingProvider
{
	protected Map<String, String> data = new LinkedHashMap<String, String>();
	protected long timeout = 0;
	protected int requestCnt = 0;
	protected String candyId = "", candyName = "candyId", ipAddr = null;
	protected Candy sessionCandy;
	protected Account currentAccount = null;
	protected List<String> pendingMessages = Lists.newArrayList();
	
	protected Map<String, Candy> candies = new LinkedHashMap<String, Candy>();
	protected HttpRequest request;
	protected Site failoverSite;
	protected boolean stale = false;
	protected boolean isValid = true;
	protected boolean changesMade = false;
	
	protected final Binding binding = new Binding();
	
	protected CodeEvalFactory factory = null;
	
	private PersistentSession()
	{
		candyName = Loader.getConfig().getString( "sessions.defaultSessionName", candyName );
	}
	
	/**
	 * Initializes a new session based on the supplied HttpRequest.
	 * 
	 * @param _request
	 */
	protected PersistentSession(HttpRequest _request)
	{
		this();
		setRequest( _request, false );
	}
	
	protected PersistentSession(ResultSet rs) throws SessionException
	{
		this();
		
		try
		{
			request = null;
			stale = true;
			
			timeout = rs.getInt( "timeout" );
			ipAddr = rs.getString( "ipAddr" );
			
			if ( !rs.getString( "data" ).isEmpty() )
				data = new Gson().fromJson( rs.getString( "data" ), new TypeToken<Map<String, String>>()
				{
					private static final long serialVersionUID = 2808406085740098578L;
				}.getType() );
			
			if ( rs.getString( "sessionName" ) != null && !rs.getString( "sessionName" ).isEmpty() )
				candyName = rs.getString( "sessionName" );
			candyId = rs.getString( "sessionId" );
			
			if ( timeout < Common.getEpoch() )
				throw new SessionException( "This session expired at " + timeout + " epoch!" );
			
			if ( rs.getString( "sessionSite" ) == null || rs.getString( "sessionSite" ).isEmpty() )
				failoverSite = Loader.getSiteManager().getFrameworkSite();
			else
				failoverSite = Loader.getSiteManager().getSiteById( rs.getString( "sessionSite" ) );
			
			sessionCandy = new Candy( candyName, rs.getString( "sessionId" ) );
			candies.put( candyName, sessionCandy );
			
			loginSessionUser();
			
			Loader.getLogger().info( ChatColor.DARK_AQUA + "Session Restored `" + this + "`" );
		}
		catch ( SQLException e )
		{
			throw new SessionException( e );
		}
	}
	
	protected void setRequest( HttpRequest _request, Boolean _stale )
	{
		request = _request;
		stale = _stale;
		
		failoverSite = request.getSite();
		ipAddr = request.getRemoteAddr();
		
		Map<String, Candy> pulledCandies = pullCandies( _request );
		pulledCandies.putAll( candies );
		candies = pulledCandies;
		
		if ( request.getSite().getYaml() != null )
		{
			String _candyName = request.getSite().getYaml().getString( "sessions.cookie-name", candyName );
			
			if ( !_candyName.equals( candyName ) )
				if ( candies.containsKey( candyName ) )
				{
					candies.put( _candyName, candies.get( candyName ) );
					candies.remove( candyName );
					candyName = _candyName;
				}
				else
				{
					candyName = _candyName;
				}
		}
		
		sessionCandy = candies.get( candyName );
		
		initSession();
		
		if ( request != null )
		{
			binding.setVariable( "request", request );
			binding.setVariable( "response", request.getResponse() );
		}
		binding.setVariable( "__FILE__", new File( "" ) );
	}
	
	protected void loginSessionUser()
	{
		String username = getArgument( "user" );
		String password = getArgument( "pass" );
		
		try
		{
			Account user = Loader.getAccountsManager().attemptLogin( this, username, password );
			currentAccount = user;
			Loader.getLogger().info( ChatColor.GREEN + "Login Restored `Username \"" + username + "\", Password \"" + password + "\", UserId \"" + user.getAccountId() + "\", Display Name \"" + user.getDisplayName() + "\"`" );
		}
		catch ( LoginException l )
		{
			// Loader.getLogger().warning( ChatColor.GREEN + "Login Status: No Valid Login Present" );
		}
	}
	
	protected void handleUserProtocols()
	{
		if ( !pendingMessages.isEmpty() )
		{
			// request.getResponse().sendMessage( pendingMessages.toArray( new String[0] ) );
		}
		
		if ( request == null )
		{
			Loader.getLogger().warning( "PersistentSession: Request was misteriously empty for an unknown reason." );
			return;
		}
		
		String username = request.getArgument( "user" );
		String password = request.getArgument( "pass" );
		String remember = request.getArgumentBoolean( "remember" ) ? "true" : "false";
		String target = request.getArgument( "target" );
		
		if ( request.getArgument( "logout", "", true ) != null )
		{
			logoutAccount();
			
			if ( target.isEmpty() )
				target = request.getSite().getYaml().getString( "scripts.login-form", "/login" );
			
			request.getResponse().sendRedirect( target + "?ok=You have been successfully logged out." );
			return;
		}
		
		if ( !username.isEmpty() && !password.isEmpty() )
		{
			try
			{
				Account user = Loader.getAccountsManager().attemptLogin( this, username, password );
				
				currentAccount = user;
				
				String loginPost = ( target.isEmpty() ) ? request.getSite().getYaml().getString( "scripts.login-post", "/panel" ) : target;
				
				setArgument( "remember", remember );
				
				Loader.getLogger().info( ChatColor.GREEN + "Login Success `Username \"" + username + "\", Password \"" + password + "\", UserId \"" + user.getAccountId() + "\", Display Name \"" + user.getDisplayName() + "\"`" );
				request.getResponse().sendRedirect( loginPost );
				
			}
			catch ( LoginException l )
			{
				//l.printStackTrace();
				
				String loginForm = request.getSite().getYaml().getString( "scripts.login-form", "/login" );
				
				if ( l.getAccount() != null )
					Loader.getLogger().warning( "Login Failed `Username \"" + username + "\", Password \"" + password + "\", UserId \"" + l.getAccount().getAccountId() + "\", Display Name \"" + l.getAccount().getDisplayName() + "\", Reason \"" + l.getMessage() + "\"`" );
				
				request.getResponse().sendRedirect( loginForm + "?ok=" + l.getMessage() + "&target=" + target );
			}
		}
		else if ( currentAccount == null )
		{
			username = getArgument( "user" );
			password = getArgument( "pass" );
			
			if ( username != null && !username.isEmpty() && password != null && !password.isEmpty() )
			{
				try
				{
					Account user = Loader.getAccountsManager().attemptLogin( this, username, password );
					
					currentAccount = user;
					
					Loader.getLogger().info( ChatColor.GREEN + "Login Success `Username \"" + username + "\", Password \"" + password + "\", UserId \"" + user.getAccountId() + "\", Display Name \"" + user.getDisplayName() + "\"`" );
				}
				catch ( LoginException l )
				{
					Loader.getLogger().warning( ChatColor.GREEN + "Login Failed `No Valid Login Present`" );
				}
			}
			else
				currentAccount = null;
		}
		else
		{
			try
			{
				currentAccount.reloadAndValidate(); // <- Is this being overly redundant?
				Loader.getLogger().info( ChatColor.GREEN + "Current Login `Username \"" + currentAccount.getName() + "\", Password \"" + currentAccount.getMetaData().getPassword() + "\", UserId \"" + currentAccount.getAccountId() + "\", Display Name \"" + currentAccount.getDisplayName() + "\"`" );
			}
			catch ( LoginException e )
			{
				currentAccount = null;
				Loader.getLogger().warning( ChatColor.GREEN + "Login Failed `There was a login present but it failed validation with error: " + e.getMessage() + "`" );
			}
		}
		
		if ( currentAccount != null )
			currentAccount.putHandler( this );
		
		if ( !stale || Loader.getConfig().getBoolean( "sessions.rearmTimeoutWithEachRequest" ) )
			rearmTimeout();
	}
	
	public void setGlobal( String key, Object val )
	{
		binding.setVariable( key, val );
	}
	
	public Object getGlobal( String key )
	{
		return binding.getVariable( key );
	}
	
	@SuppressWarnings( "unchecked" )
	public Map<String, Object> getGlobals()
	{
		return binding.getVariables();
	}
	
	protected Binding getBinding()
	{
		return binding;
	}
	
	protected void initSession()
	{
		DatabaseEngine sql = Loader.getPersistenceManager().getDatabase();
		
		if ( sessionCandy != null )
		{
			ResultSet rs = null;
			try
			{
				rs = sql.query( "SELECT * FROM `sessions` WHERE `sessionId` = '" + sessionCandy.getValue() + "'" );
			}
			catch ( SQLException e1 )
			{
				e1.printStackTrace();
			}
			
			candyId = sessionCandy.getValue();
			
			if ( rs == null || sql.getRowCount( rs ) < 1 )
				sessionCandy = null;
			else
			{
				try
				{
					timeout = rs.getInt( "timeout" );
					String _ipAddr = rs.getString( "ipAddr" );
					
					if ( !rs.getString( "data" ).isEmpty() )
					{
						Map<String, String> tmpData = new Gson().fromJson( rs.getString( "data" ), new TypeToken<Map<String, String>>()
						{
							private static final long serialVersionUID = -1734352198651744570L;
						}.getType() );
						
						if ( changesMade )
						{
							tmpData.putAll( data );
							data = tmpData;
						}
						else
							data.putAll( tmpData );
					}
					
					// Possible Session Hijacking! nullify!!!
					if ( !_ipAddr.equals( ipAddr ) && !Loader.getConfig().getBoolean( "sessions.allowIPChange" ) )
					{
						sessionCandy = null;
					}
					
					ipAddr = _ipAddr;
					
					List<PersistentSession> sessions = Loader.getPersistenceManager().getSessionsByIp( ipAddr );
					if ( sessions.size() > Loader.getConfig().getInt( "sessions.maxSessionsPerIP" ) )
					{
						long oldestTime = Common.getEpoch();
						PersistentSession oldest = null;
						
						for ( PersistentSession s : sessions )
						{
							if ( s != this && s.getTimeout() < oldestTime )
							{
								oldest = s;
								oldestTime = s.getTimeout();
							}
						}
						
						if ( oldest != null )
							PersistenceManager.destroySession( oldest );
					}
				}
				catch ( JsonSyntaxException | SQLException e )
				{
					e.printStackTrace();
					sessionCandy = null;
				}
			}
		}
		
		if ( sessionCandy == null )
		{
			int defaultLife = ( request != null && request.getSite().getYaml() != null ) ? request.getSite().getYaml().getInt( "sessions.default-life", 604800 ) : 604800;
			
			if ( candyId == null || candyId.isEmpty() )
				candyId = StringUtil.md5( request.getURI().toString() + System.currentTimeMillis() );
			
			sessionCandy = new Candy( candyName, candyId );
			
			sessionCandy.setMaxAge( defaultLife );
			
			if ( request.getSite().getDomain() != null && !request.getSite().getDomain().isEmpty() && request.getParentDomain().toLowerCase().contains( request.getSite().getDomain().toLowerCase() ) )
				sessionCandy.setDomain( "." + request.getSite().getDomain() );
			else if ( request.getParentDomain() != null && !request.getParentDomain().isEmpty() )
				sessionCandy.setDomain( "." + request.getParentDomain() );
			
			sessionCandy.setPath( "/" );
			
			candies.put( candyName, sessionCandy );
			
			String dataJson = new Gson().toJson( data );
			
			timeout = Common.getEpoch() + Loader.getConfig().getInt( "sessions.defaultTimeout", 3600 );
			
			try
			{
				sql.queryUpdate( "INSERT INTO `sessions` (`sessionId`, `timeout`, `ipAddr`, `sessionName`, `sessionSite`, `data`)VALUES('" + candyId + "', '" + timeout + "', '" + ipAddr + "', '" + candyName + "', '" + getSite().getName() + "', '" + dataJson + "');" );
			}
			catch ( SQLException e )
			{
				e.printStackTrace();
			}
		}
		
		if ( stale )
			Loader.getLogger().info( ChatColor.DARK_AQUA + "Session Requested `" + this + "`" );
		else
			Loader.getLogger().info( ChatColor.DARK_AQUA + "Session Created `" + this + "`" );
	}
	
	protected void saveSession( boolean force )
	{
		if ( force || changesMade )
		{
			DatabaseEngine sql = Loader.getPersistenceManager().getDatabase();
			
			String dataJson = new Gson().toJson( data );
			
			if ( sql != null )
				try
				{
					sql.queryUpdate( "UPDATE `sessions` SET `data` = '" + dataJson + "', `timeout` = '" + timeout + "', `sessionName` = '" + candyName + "', `ipAddr` = '" + ipAddr + "', `sessionSite` = '" + getSite().getName() + "' WHERE `sessionId` = '" + candyId + "';" );
				}
				catch ( SQLException e )
				{
					Loader.getLogger().severe( "There was an exception thorwn while trying to save the session.", e );
				}
			else
				Loader.getLogger().severe( "SQL is NULL. Can't save session." );
			
			changesMade = false;
		}
	}
	
	public String toString()
	{
		String extra = "";
		
		if ( failoverSite != null )
			extra += ",site=" + failoverSite.getName();
		
		return candyName + "{id=" + candyId + ",ipAddr=" + ipAddr + ",timeout=" + timeout + ",data=" + data + ",stale=" + stale + ",requestCount=" + requestCnt + extra + "}";
	}
	
	/**
	 * Determines if this session belongs to the supplied HttpRequest based on the SessionId cookie.
	 * 
	 * @param request
	 * @return boolean
	 */
	protected boolean matchClient( HttpRequest request )
	{
		String _candyName = request.getSite().getYaml().getString( "sessions.cookie-name", Loader.getConfig().getString( "sessions.defaultSessionName", "sessionId" ) );
		Map<String, Candy> requestCandys = pullCandies( request );
		
		return ( requestCandys.containsKey( _candyName ) && getCandy( candyName ).compareTo( requestCandys.get( _candyName ) ) );
	}
	
	/**
	 * Returns a cookie if existent in the session.
	 * 
	 * @param key
	 * @return Candy
	 */
	public Candy getCandy( String key )
	{
		return ( candies.containsKey( key ) ) ? candies.get( key ) : new Candy( key, null );
	}
	
	public Map<String, Candy> pullCandies( HttpRequest request )
	{
		Map<String, Candy> candies = new LinkedHashMap<String, Candy>();
		List<String> var1 = request.getHeaders().get( "Cookie" );
		
		if ( var1 == null || var1.isEmpty() )
			return candies;
		
		String[] var2 = var1.get( 0 ).split( "\\;" );
		
		for ( String var3 : var2 )
		{
			String[] var4 = var3.trim().split( "\\=" );
			
			if ( var4.length == 2 )
			{
				candies.put( var4[0], new Candy( var4[0], var4[1] ) );
			}
		}
		
		return candies;
	}
	
	/**
	 * Indicates if this session was previously used in a prior request
	 * 
	 * @return boolean
	 */
	public boolean isStale()
	{
		return stale;
	}
	
	public String getId()
	{
		return candyId;
	}
	
	public void setArgument( String key, String value )
	{
		if ( value == null )
			data.remove( key );
		
		data.put( key, value );
		changesMade = true;
	}
	
	public String getArgument( String key )
	{
		if ( !data.containsKey( key ) )
			return "";
		
		if ( data.get( key ) == null )
			return "";
		
		return data.get( key );
	}
	
	public boolean isSet( String key )
	{
		return data.containsKey( key );
	}
	
	public void setCookieExpiry( int valid )
	{
		sessionCandy.setMaxAge( valid );
	}
	
	public void destroy() throws SQLException
	{
		timeout = Common.getEpoch();
		setCookieExpiry( 0 );
		
		PersistenceManager.destroySession( this );
	}
	
	public void rearmTimeout()
	{
		long defaultTimeout = Loader.getConfig().getInt( "sessions.defaultTimeout", 3600 );
		
		// Grant the timeout an additional 10 minutes per request, capped at one hour or 6 requests.
		requestCnt++;
		
		// Grant the timeout an additional 2 hours for having a user logged in.
		if ( getUserState() )
		{
			defaultTimeout = Loader.getConfig().getInt( "sessions.defaultTimeoutWithLogin", 86400 );
			
			if ( StringUtil.isTrue( getArgument( "remember" ) ) )
				defaultTimeout = Loader.getConfig().getInt( "sessions.defaultTimeoutRememberMe", 604800 );
			
			if ( Loader.getConfig().getBoolean( "allowNoTimeoutPermission" ) && currentAccount.hasPermission( "chiori.noTimeout" ) )
				defaultTimeout = 31096821392L;
		}
		
		timeout = Common.getEpoch() + defaultTimeout + ( Math.min( requestCnt, 6 ) * 600 );
		sessionCandy.setExpiration( timeout );
	}
	
	public long getTimeout()
	{
		return timeout;
	}
	
	/**
	 * This method is only to be used to make this session unremovable from memory by the session garbage collector. Be
	 * sure that you rearm the timeout at some point to prevent build ups in memory.
	 */
	public void infiniTimeout()
	{
		timeout = 0;
	}
	
	// TODO: Future add of setDomain, setCookieName, setSecure (http verses https)
	
	public boolean getUserState()
	{
		return ( currentAccount != null );
	}
	
	public Account getCurrentAccount()
	{
		return currentAccount;
	}
	
	/**
	 * Logout the current logged in user.
	 */
	public void logoutAccount()
	{
		if ( currentAccount != null )
			Loader.getLogger().info( ChatColor.GREEN + "User Logout `" + currentAccount + "`" );
		
		// setArgument( "remember", null );
		setArgument( "user", null );
		setArgument( "pass", null );
		currentAccount = null;
		
		for ( Account u : Loader.getAccountsManager().getOnlineAccounts() )
			u.removeHandler( this );
	}
	
	public HttpRequest getRequest()
	{
		return request;
	}
	
	public HttpResponse getResponse()
	{
		return request.getResponse();
	}
	
	/**
	 * Called when request has finished so that this stale session can nullify unneeded stuff such as the HttpRequest
	 */
	public void releaseResources()
	{
		request = null;
	}
	
	@Override
	public boolean kick( String kickMessage )
	{
		logoutAccount();
		pendingMessages.add( kickMessage );
		
		return true;
	}
	
	@Override
	public void sendMessage( String... messages )
	{
		for ( String m : messages )
			pendingMessages.add( m );
	}
	
	public Site getSite()
	{
		if ( getRequest() != null )
			return getRequest().getSite();
		else if ( failoverSite == null )
			return Loader.getSiteManager().getFrameworkSite();
		else
			return failoverSite;
	}
	
	@Override
	public String getIpAddr()
	{
		return ipAddr;
	}
	
	public void requireLogin() throws IOException
	{
		requireLogin( null );
	}
	
	/**
	 * First checks in an account is present, sends to login page if not.
	 * Second checks if the present accounts has the specified permission.
	 * 
	 * @param permission
	 * @throws IOException
	 */
	public void requireLogin( String permission ) throws IOException
	{
		if ( currentAccount == null )
			request.getResponse().sendLoginPage();
		
		if ( permission != null )
			if ( !currentAccount.hasPermission( permission ) )
				request.getResponse().sendError( HttpCode.HTTP_FORBIDDEN, "You must have the `" + permission + "` in order to view this page!" );
	}
	
	// A session can't handle just any sentient object.
	// At least for the time being.
	@Override
	public void attachSentient( Sentient sentient )
	{
		if ( sentient instanceof Account )
			currentAccount = (Account) sentient;
		else
			isValid = false;
	}
	
	@Override
	public boolean isValid()
	{
		return isValid;
	}
	
	@Override
	public Sentient getSentient()
	{
		return currentAccount;
	}
	
	@Override
	public void removeSentient()
	{
		currentAccount = null;
	}
	
	/**
	 * It's HIGHLY important that you call the .unlock() method on the factory once your done with it or else it will build up in memory.
	 */
	@Override
	public CodeEvalFactory getCodeFactory()
	{
		if ( factory == null )
			factory = CodeEvalFactory.create( binding );
		
		return factory;
	}
	
	public ConfigurationManagerWrapper getConfigurationManager()
	{
		return new ConfigurationManagerWrapper( request.getSession() );
	}

	@Override
	public String getName()
	{
		if ( currentAccount == null )
			return "(NULL)";
		
		return currentAccount.getName();
	}
}
