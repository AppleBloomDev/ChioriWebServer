/**
 * Mozilla Public License, version 2.0
 *
 * 1. Definitions
 *
 * 1.1. “Contributor”
 *
 *      means each individual or legal entity that creates, contributes to the
 *      creation of, or owns Covered Software.
 *
 * 1.2. “Contributor Version”
 *
 *      means the combination of the Contributions of others (if any) used by a
 *      Contributor and that particular Contributor’s Contribution.
 *
 * 1.3. “Contribution”
 *
 *      means Covered Software of a particular Contributor.
 *
 * 1.4. “Covered Software”
 *
 *      means Source Code Form to which the initial Contributor has attached the
 *      notice in Exhibit A, the Executable Form of such Source Code Form, and
 *      Modifications of such Source Code Form, in each case including portions
 *      thereof.
 *
 * 1.5. “Incompatible With Secondary Licenses”
 *      means
 *
 *      a. that the initial Contributor has attached the notice described in
 *         Exhibit B to the Covered Software; or
 *
 *      b. that the Covered Software was made available under the terms of version
 *         1.1 or earlier of the License, but not also under the terms of a
 *         Secondary License.
 *
 * 1.6. “Executable Form”
 *
 *      means any form of the work other than Source Code Form.
 *
 * 1.7. “Larger Work”
 *
 *      means a work that combines Covered Software with other material, in a separate
 *      file or files, that is not Covered Software.
 *
 * 1.8. “License”
 *
 *      means this document.
 *
 * 1.9. “Licensable”
 *
 *      means having the right to grant, to the maximum extent possible, whether at the
 *      time of the initial grant or subsequently, any and all of the rights conveyed by
 *      this License.
 *
 * 1.10. “Modifications”
 *
 *      means any of the following:
 *
 *      a. any file in Source Code Form that results from an addition to, deletion
 *         from, or modification of the contents of Covered Software; or
 *
 *      b. any new file in Source Code Form that contains any Covered Software.
 *
 * 1.11. “Patent Claims” of a Contributor
 *
 *       means any patent claim(s), including without limitation, method, process,
 *       and apparatus claims, in any patent Licensable by such Contributor that
 *       would be infringed, but for the grant of the License, by the making,
 *       using, selling, offering for sale, having made, import, or transfer of
 *       either its Contributions or its Contributor Version.
 *
 * 1.12. “Secondary License”
 *
 *       means either the GNU General Public License, Version 2.0, the GNU Lesser
 *       General Public License, Version 2.1, the GNU Affero General Public
 *       License, Version 3.0, or any later versions of those licenses.
 *
 * 1.13. “Source Code Form”
 *
 *       means the form of the work preferred for making modifications.
 *
 * 1.14. “You” (or “Your”)
 *
 *       means an individual or a legal entity exercising rights under this
 *       License. For legal entities, “You” includes any entity that controls, is
 *       controlled by, or is under common control with You. For purposes of this
 *       definition, “control” means (a) the power, direct or indirect, to cause
 *       the direction or management of such entity, whether by contract or
 *       otherwise, or (b) ownership of more than fifty percent (50%) of the
 *       outstanding shares or beneficial ownership of such entity.
 *
 *
 * 2. License Grants and Conditions
 *
 * 2.1. Grants
 *
 *      Each Contributor hereby grants You a world-wide, royalty-free,
 *      non-exclusive license:
 *
 *      a. under intellectual property rights (other than patent or trademark)
 *         Licensable by such Contributor to use, reproduce, make available,
 *         modify, display, perform, distribute, and otherwise exploit its
 *         Contributions, either on an unmodified basis, with Modifications, or as
 *         part of a Larger Work; and
 *
 *      b. under Patent Claims of such Contributor to make, use, sell, offer for
 *         sale, have made, import, and otherwise transfer either its Contributions
 *         or its Contributor Version.
 *
 * 2.2. Effective Date
 *
 *      The licenses granted in Section 2.1 with respect to any Contribution become
 *      effective for each Contribution on the date the Contributor first distributes
 *      such Contribution.
 *
 * 2.3. Limitations on Grant Scope
 *
 *      The licenses granted in this Section 2 are the only rights granted under this
 *      License. No additional rights or licenses will be implied from the distribution
 *      or licensing of Covered Software under this License. Notwithstanding Section
 *      2.1(b) above, no patent license is granted by a Contributor:
 *
 *      a. for any code that a Contributor has removed from Covered Software; or
 *
 *      b. for infringements caused by: (i) Your and any other third party’s
 *         modifications of Covered Software, or (ii) the combination of its
 *         Contributions with other software (except as part of its Contributor
 *         Version); or
 *
 *      c. under Patent Claims infringed by Covered Software in the absence of its
 *         Contributions.
 *
 *      This License does not grant any rights in the trademarks, service marks, or
 *      logos of any Contributor (except as may be necessary to comply with the
 *      notice requirements in Section 3.4).
 *
 * 2.4. Subsequent Licenses
 *
 *      No Contributor makes additional grants as a result of Your choice to
 *      distribute the Covered Software under a subsequent version of this License
 *      (see Section 10.2) or under the terms of a Secondary License (if permitted
 *      under the terms of Section 3.3).
 *
 * 2.5. Representation
 *
 *      Each Contributor represents that the Contributor believes its Contributions
 *      are its original creation(s) or it has sufficient rights to grant the
 *      rights to its Contributions conveyed by this License.
 *
 * 2.6. Fair Use
 *
 *      This License is not intended to limit any rights You have under applicable
 *      copyright doctrines of fair use, fair dealing, or other equivalents.
 *
 * 2.7. Conditions
 *
 *      Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in
 *      Section 2.1.
 *
 *
 * 3. Responsibilities
 *
 * 3.1. Distribution of Source Form
 *
 *      All distribution of Covered Software in Source Code Form, including any
 *      Modifications that You create or to which You contribute, must be under the
 *      terms of this License. You must inform recipients that the Source Code Form
 *      of the Covered Software is governed by the terms of this License, and how
 *      they can obtain a copy of this License. You may not attempt to alter or
 *      restrict the recipients’ rights in the Source Code Form.
 *
 * 3.2. Distribution of Executable Form
 *
 *      If You distribute Covered Software in Executable Form then:
 *
 *      a. such Covered Software must also be made available in Source Code Form,
 *         as described in Section 3.1, and You must inform recipients of the
 *         Executable Form how they can obtain a copy of such Source Code Form by
 *         reasonable means in a timely manner, at a charge no more than the cost
 *         of distribution to the recipient; and
 *
 *      b. You may distribute such Executable Form under the terms of this License,
 *         or sublicense it under different terms, provided that the license for
 *         the Executable Form does not attempt to limit or alter the recipients’
 *         rights in the Source Code Form under this License.
 *
 * 3.3. Distribution of a Larger Work
 *
 *      You may create and distribute a Larger Work under terms of Your choice,
 *      provided that You also comply with the requirements of this License for the
 *      Covered Software. If the Larger Work is a combination of Covered Software
 *      with a work governed by one or more Secondary Licenses, and the Covered
 *      Software is not Incompatible With Secondary Licenses, this License permits
 *      You to additionally distribute such Covered Software under the terms of
 *      such Secondary License(s), so that the recipient of the Larger Work may, at
 *      their option, further distribute the Covered Software under the terms of
 *      either this License or such Secondary License(s).
 *
 * 3.4. Notices
 *
 *      You may not remove or alter the substance of any license notices (including
 *      copyright notices, patent notices, disclaimers of warranty, or limitations
 *      of liability) contained within the Source Code Form of the Covered
 *      Software, except that You may alter any license notices to the extent
 *      required to remedy known factual inaccuracies.
 *
 * 3.5. Application of Additional Terms
 *
 *      You may choose to offer, and to charge a fee for, warranty, support,
 *      indemnity or liability obligations to one or more recipients of Covered
 *      Software. However, You may do so only on Your own behalf, and not on behalf
 *      of any Contributor. You must make it absolutely clear that any such
 *      warranty, support, indemnity, or liability obligation is offered by You
 *      alone, and You hereby agree to indemnify every Contributor for any
 *      liability incurred by such Contributor as a result of warranty, support,
 *      indemnity or liability terms You offer. You may include additional
 *      disclaimers of warranty and limitations of liability specific to any
 *      jurisdiction.
 *
 * 4. Inability to Comply Due to Statute or Regulation
 *
 *    If it is impossible for You to comply with any of the terms of this License
 *    with respect to some or all of the Covered Software due to statute, judicial
 *    order, or regulation then You must: (a) comply with the terms of this License
 *    to the maximum extent possible; and (b) describe the limitations and the code
 *    they affect. Such description must be placed in a text file included with all
 *    distributions of the Covered Software under this License. Except to the
 *    extent prohibited by statute or regulation, such description must be
 *    sufficiently detailed for a recipient of ordinary skill to be able to
 *    understand it.
 *
 * 5. Termination
 *
 * 5.1. The rights granted under this License will terminate automatically if You
 *      fail to comply with any of its terms. However, if You become compliant,
 *      then the rights granted under this License from a particular Contributor
 *      are reinstated (a) provisionally, unless and until such Contributor
 *      explicitly and finally terminates Your grants, and (b) on an ongoing basis,
 *      if such Contributor fails to notify You of the non-compliance by some
 *      reasonable means prior to 60 days after You have come back into compliance.
 *      Moreover, Your grants from a particular Contributor are reinstated on an
 *      ongoing basis if such Contributor notifies You of the non-compliance by
 *      some reasonable means, this is the first time You have received notice of
 *      non-compliance with this License from such Contributor, and You become
 *      compliant prior to 30 days after Your receipt of the notice.
 *
 * 5.2. If You initiate litigation against any entity by asserting a patent
 *      infringement claim (excluding declaratory judgment actions, counter-claims,
 *      and cross-claims) alleging that a Contributor Version directly or
 *      indirectly infringes any patent, then the rights granted to You by any and
 *      all Contributors for the Covered Software under Section 2.1 of this License
 *      shall terminate.
 *
 * 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user
 *      license agreements (excluding distributors and resellers) which have been
 *      validly granted by You or Your distributors under this License prior to
 *      termination shall survive termination.
 *
 * 6. Disclaimer of Warranty
 *
 *    Covered Software is provided under this License on an “as is” basis, without
 *    warranty of any kind, either expressed, implied, or statutory, including,
 *    without limitation, warranties that the Covered Software is free of defects,
 *    merchantable, fit for a particular purpose or non-infringing. The entire
 *    risk as to the quality and performance of the Covered Software is with You.
 *    Should any Covered Software prove defective in any respect, You (not any
 *    Contributor) assume the cost of any necessary servicing, repair, or
 *    correction. This disclaimer of warranty constitutes an essential part of this
 *    License. No use of  any Covered Software is authorized under this License
 *    except under this disclaimer.
 *
 * 7. Limitation of Liability
 *
 *    Under no circumstances and under no legal theory, whether tort (including
 *    negligence), contract, or otherwise, shall any Contributor, or anyone who
 *    distributes Covered Software as permitted above, be liable to You for any
 *    direct, indirect, special, incidental, or consequential damages of any
 *    character including, without limitation, damages for lost profits, loss of
 *    goodwill, work stoppage, computer failure or malfunction, or any and all
 *    other commercial damages or losses, even if such party shall have been
 *    informed of the possibility of such damages. This limitation of liability
 *    shall not apply to liability for death or personal injury resulting from such
 *    party’s negligence to the extent applicable law prohibits such limitation.
 *    Some jurisdictions do not allow the exclusion or limitation of incidental or
 *    consequential damages, so this exclusion and limitation may not apply to You.
 *
 * 8. Litigation
 *
 *    Any litigation relating to this License may be brought only in the courts of
 *    a jurisdiction where the defendant maintains its principal place of business
 *    and such litigation shall be governed by laws of that jurisdiction, without
 *    reference to its conflict-of-law provisions. Nothing in this Section shall
 *    prevent a party’s ability to bring cross-claims or counter-claims.
 *
 * 9. Miscellaneous
 *
 *    This License represents the complete agreement concerning the subject matter
 *    hereof. If any provision of this License is held to be unenforceable, such
 *    provision shall be reformed only to the extent necessary to make it
 *    enforceable. Any law or regulation which provides that the language of a
 *    contract shall be construed against the drafter shall not be used to construe
 *    this License against a Contributor.
 *
 *
 * 10. Versions of the License
 *
 * 10.1. New Versions
 *
 *       Mozilla Foundation is the license steward. Except as provided in Section
 *       10.3, no one other than the license steward has the right to modify or
 *       publish new versions of this License. Each version will be given a
 *       distinguishing version number.
 *
 * 10.2. Effect of New Versions
 *
 *       You may distribute the Covered Software under the terms of the version of
 *       the License under which You originally received the Covered Software, or
 *       under the terms of any subsequent version published by the license
 *       steward.
 *
 * 10.3. Modified Versions
 *
 *       If you create software not governed by this License, and you want to
 *       create a new license for such software, you may create and use a modified
 *       version of this License if you rename the license and remove any
 *       references to the name of the license steward (except to note that such
 *       modified license differs from this License).
 *
 * 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses
 *       If You choose to distribute Source Code Form that is Incompatible With
 *       Secondary Licenses under the terms of this version of the License, the
 *       notice described in Exhibit B of this License must be attached.
 *
 * Exhibit A - Source Code Form License Notice
 *
 *       This Source Code Form is subject to the
 *       terms of the Mozilla Public License, v.
 *       2.0. If a copy of the MPL was not
 *       distributed with this file, You can
 *       obtain one at
 *       http://mozilla.org/MPL/2.0/.
 *
 * If it is not possible or desirable to put the notice in a particular file, then
 * You may include the notice in a location (such as a LICENSE file in a relevant
 * directory) where a recipient would be likely to look for such a notice.
 *
 * You may add additional accurate notices of copyright ownership.
 *
 * Exhibit B - “Incompatible With Secondary Licenses” Notice
 *
 *       This Source Code Form is “Incompatible
 *       With Secondary Licenses”, as defined by
 *       the Mozilla Public License, v. 2.0.
 */
package com.chiorichan.plugin;

import java.io.File;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.Validate;

import com.chiorichan.Loader;
import com.chiorichan.account.bases.Sentient;
import com.chiorichan.bus.events.HandlerList;
import com.chiorichan.command.Command;
import com.chiorichan.command.CommandMap;
import com.chiorichan.command.PluginCommand;
import com.chiorichan.command.PluginCommandYamlParser;
import com.chiorichan.configuration.ConfigurationSection;
import com.chiorichan.permissions.Permissible;
import com.chiorichan.permissions.Permission;
import com.chiorichan.permissions.helpers.DefaultPermissions;
import com.chiorichan.plugin.anon.AnonymousLoader;
import com.chiorichan.plugin.groovy.GroovyPluginLoader;
import com.chiorichan.plugin.java.JavaPluginLoader;
import com.chiorichan.util.FileUtil;
import com.google.common.collect.ImmutableList;

/**
 * Handles all plugin management from the Server
 */
public final class PluginManager
{
	private final Map<Pattern, PluginLoader> fileAssociations = new HashMap<Pattern, PluginLoader>();
	private final List<Plugin> plugins = new ArrayList<Plugin>();
	private final Map<String, Plugin> lookupNames = new HashMap<String, Plugin>();
	private static File updateDirectory = null;
	private Set<String> loadedPlugins = new HashSet<String>();
	private PluginLoadOrder currentState = PluginLoadOrder.INITIALIZATION;
	private AnonymousLoader anonLoader;
	
	private final static CommandMap commandMap = new CommandMap();
	
	private static PluginManager instance;
	
	public PluginManager()
	{
		instance = this;
	}
	
	public void init()
	{
		
	}
	
	public static PluginManager getInstance()
	{
		return instance;
	}
	
	public static CommandMap getCommandMap()
	{
		return commandMap;
	}
	
	public void shutdown()
	{
		clearPlugins();
		commandMap.clearCommands();
	}
	
	public void enablePlugins( PluginLoadOrder type )
	{
		currentState = type;
		
		Plugin[] plugins = getPlugins();
		
		for ( Plugin plugin : plugins )
		{
			if ( ( !plugin.isEnabled() ) && ( plugin.getDescription().getLoad() == type ) )
				loadPlugin( plugin );
		}
		
		if ( type == PluginLoadOrder.POSTSERVER )
		{
			commandMap.registerServerAliases();
			Loader.getPermissionsManager().loadCustomPermissions();
			DefaultPermissions.registerCorePermissions();
		}
	}
	
	public void loadPlugins()
	{
		registerInterface( JavaPluginLoader.class );
		registerInterface( GroovyPluginLoader.class );
		
		anonLoader = new AnonymousLoader();
		
		File pluginFolder = (File) Loader.getOptions().valueOf( "plugins" );
		
		if ( pluginFolder.exists() )
		{
			Plugin[] plugins = loadPlugins( pluginFolder );
			for ( Plugin plugin : plugins )
			{
				try
				{
					String message = String.format( "Loading %s", plugin.getDescription().getFullName() );
					Loader.getLogger().info( message );
					plugin.onLoad();
				}
				catch ( Throwable ex )
				{
					Loader.getLogger().log( Level.SEVERE, ex.getMessage() + " initializing " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
				}
			}
		}
		else
			pluginFolder.mkdir();
	}
	
	public PluginLoadOrder getCurrentLoadState()
	{
		return currentState;
	}
	
	/**
	 * Registers the specified plugin loader
	 * 
	 * @param loader
	 *             Class name of the PluginLoader to register
	 * @throws IllegalArgumentException
	 *              Thrown when the given Class is not a valid PluginLoader
	 */
	public void registerInterface( Class<? extends PluginLoader> loader ) throws IllegalArgumentException
	{
		PluginLoader instance;
		
		if ( PluginLoader.class.isAssignableFrom( loader ) )
		{
			Constructor<? extends PluginLoader> constructor;
			
			try
			{
				constructor = loader.getConstructor();
				instance = constructor.newInstance();
			}
			catch ( NoSuchMethodException ex )
			{
				try
				{
					constructor = loader.getConstructor( Loader.class );
					instance = constructor.newInstance( Loader.getInstance() );
				}
				catch ( NoSuchMethodException ex1 )
				{
					String className = loader.getName();
					
					throw new IllegalArgumentException( String.format( "Class %s does not have a public %s(Server) constructor", className, className ), ex1 );
				}
				catch ( Exception ex1 )
				{
					throw new IllegalArgumentException( String.format( "Unexpected exception %s while attempting to construct a new instance of %s", ex.getClass().getName(), loader.getName() ), ex1 );
				}
			}
			catch ( Exception ex )
			{
				throw new IllegalArgumentException( String.format( "Unexpected exception %s while attempting to construct a new instance of %s", ex.getClass().getName(), loader.getName() ), ex );
			}
		}
		else
		{
			throw new IllegalArgumentException( String.format( "Class %s does not implement interface PluginLoader", loader.getName() ) );
		}
		
		Pattern[] patterns = instance.getPluginFileFilters();
		
		synchronized ( this )
		{
			for ( Pattern pattern : patterns )
			{
				fileAssociations.put( pattern, instance );
			}
		}
	}
	
	/**
	 * Loads the plugins contained within the specified directory
	 * 
	 * @param directory
	 *             Directory to check for plugins
	 * @return A list of all plugins loaded
	 */
	public Plugin[] loadPlugins( File directory )
	{
		Validate.notNull( directory, "Directory cannot be null" );
		Validate.isTrue( directory.isDirectory(), "Directory must be a directory" );
		
		List<Plugin> result = new ArrayList<Plugin>();
		Set<Pattern> filters = fileAssociations.keySet();
		
		if ( !( Loader.getInstance().getUpdateFolder().equals( "" ) ) )
		{
			updateDirectory = new File( directory, Loader.getInstance().getUpdateFolder() );
		}
		
		Map<String, File> plugins = new HashMap<String, File>();
		Map<String, Collection<String>> dependencies = new HashMap<String, Collection<String>>();
		Map<String, Collection<String>> softDependencies = new HashMap<String, Collection<String>>();
		
		// This is where it figures out all possible plugins
		for ( File file : directory.listFiles() )
		{
			PluginLoader loader = null;
			for ( Pattern filter : filters )
			{
				Matcher match = filter.matcher( file.getName() );
				if ( match.find() )
				{
					loader = fileAssociations.get( filter );
				}
			}
			
			if ( loader == null )
				continue;
			
			PluginDescriptionFile description = null;
			try
			{
				description = loader.getPluginDescription( file );
			}
			catch ( InvalidDescriptionException ex )
			{
				Loader.getLogger().log( Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex );
				continue;
			}
			
			plugins.put( description.getName(), file );
			
			// TODO: Make it so packets can be registered with the TCP Network from the plugin.yml file
			
			Collection<String> softDependencySet = description.getSoftDepend();
			if ( softDependencySet != null )
			{
				if ( softDependencies.containsKey( description.getName() ) )
				{
					// Duplicates do not matter, they will be removed together if applicable
					softDependencies.get( description.getName() ).addAll( softDependencySet );
				}
				else
				{
					softDependencies.put( description.getName(), new LinkedList<String>( softDependencySet ) );
				}
			}
			
			Collection<String> dependencySet = description.getDepend();
			if ( dependencySet != null )
			{
				dependencies.put( description.getName(), new LinkedList<String>( dependencySet ) );
			}
			
			Collection<String> loadBeforeSet = description.getLoadBefore();
			if ( loadBeforeSet != null )
			{
				for ( String loadBeforeTarget : loadBeforeSet )
				{
					if ( softDependencies.containsKey( loadBeforeTarget ) )
					{
						softDependencies.get( loadBeforeTarget ).add( description.getName() );
					}
					else
					{
						// softDependencies is never iterated, so 'ghost' plugins aren't an issue
						Collection<String> shortSoftDependency = new LinkedList<String>();
						shortSoftDependency.add( description.getName() );
						softDependencies.put( loadBeforeTarget, shortSoftDependency );
					}
				}
			}
		}
		
		while ( !plugins.isEmpty() )
		{
			boolean missingDependency = true;
			Iterator<String> pluginIterator = plugins.keySet().iterator();
			
			while ( pluginIterator.hasNext() )
			{
				String plugin = pluginIterator.next();
				
				if ( dependencies.containsKey( plugin ) )
				{
					Iterator<String> dependencyIterator = dependencies.get( plugin ).iterator();
					
					while ( dependencyIterator.hasNext() )
					{
						String dependency = dependencyIterator.next();
						
						// Dependency loaded
						if ( loadedPlugins.contains( dependency ) )
						{
							dependencyIterator.remove();
							
							// We have a dependency not found
						}
						else if ( !plugins.containsKey( dependency ) )
						{
							missingDependency = false;
							File file = plugins.get( plugin );
							pluginIterator.remove();
							softDependencies.remove( plugin );
							dependencies.remove( plugin );
							
							Loader.getLogger().log( Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", new UnknownDependencyException( dependency ) );
							break;
						}
					}
					
					if ( dependencies.containsKey( plugin ) && dependencies.get( plugin ).isEmpty() )
					{
						dependencies.remove( plugin );
					}
				}
				if ( softDependencies.containsKey( plugin ) )
				{
					Iterator<String> softDependencyIterator = softDependencies.get( plugin ).iterator();
					
					while ( softDependencyIterator.hasNext() )
					{
						String softDependency = softDependencyIterator.next();
						
						// Soft depend is no longer around
						if ( !plugins.containsKey( softDependency ) )
						{
							softDependencyIterator.remove();
						}
					}
					
					if ( softDependencies.get( plugin ).isEmpty() )
					{
						softDependencies.remove( plugin );
					}
				}
				if ( !( dependencies.containsKey( plugin ) || softDependencies.containsKey( plugin ) ) && plugins.containsKey( plugin ) )
				{
					// We're clear to load, no more soft or hard dependencies left
					File file = plugins.get( plugin );
					pluginIterator.remove();
					missingDependency = false;
					
					try
					{
						result.add( loadPlugin( file ) );
						loadedPlugins.add( plugin );
						continue;
					}
					catch ( InvalidPluginException ex )
					{
						Loader.getLogger().log( Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex );
					}
				}
			}
			
			if ( missingDependency )
			{
				// We now iterate over plugins until something loads
				// This loop will ignore soft dependencies
				pluginIterator = plugins.keySet().iterator();
				
				while ( pluginIterator.hasNext() )
				{
					String plugin = pluginIterator.next();
					
					if ( !dependencies.containsKey( plugin ) )
					{
						softDependencies.remove( plugin );
						missingDependency = false;
						File file = plugins.get( plugin );
						pluginIterator.remove();
						
						try
						{
							result.add( loadPlugin( file ) );
							loadedPlugins.add( plugin );
							break;
						}
						catch ( InvalidPluginException ex )
						{
							Loader.getLogger().log( Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex );
						}
					}
				}
				// We have no plugins left without a depend
				if ( missingDependency )
				{
					softDependencies.clear();
					dependencies.clear();
					Iterator<File> failedPluginIterator = plugins.values().iterator();
					
					while ( failedPluginIterator.hasNext() )
					{
						File file = failedPluginIterator.next();
						failedPluginIterator.remove();
						Loader.getLogger().log( Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': circular dependency detected" );
					}
				}
			}
		}
		
		return result.toArray( new Plugin[result.size()] );
	}
	
	/**
	 * Loads the plugin in the specified file
	 * <p>
	 * File must be valid according to the current enabled Plugin interfaces
	 * 
	 * @param file
	 *             File containing the plugin to load
	 * @return The Plugin loaded, or null if it was invalid
	 * @throws InvalidPluginException
	 *              Thrown when the specified file is not a valid plugin
	 * @throws UnknownDependencyException
	 *              If a required dependency could not be found
	 */
	public synchronized Plugin loadPlugin( File file ) throws InvalidPluginException, UnknownDependencyException
	{
		Validate.notNull( file, "File cannot be null" );
		
		checkUpdate( file );
		
		Set<Pattern> filters = fileAssociations.keySet();
		Plugin result = null;
		
		for ( Pattern filter : filters )
		{
			String name = file.getName();
			Matcher match = filter.matcher( name );
			
			if ( match.find() )
			{
				PluginLoader loader = fileAssociations.get( filter );
				
				result = loader.loadPlugin( file );
			}
		}
		
		if ( result != null )
		{
			plugins.add( result );
			lookupNames.put( result.getDescription().getName(), result );
		}
		
		return result;
	}
	
	private void checkUpdate( File file )
	{
		if ( updateDirectory == null || !updateDirectory.isDirectory() )
		{
			return;
		}
		
		File updateFile = new File( updateDirectory, file.getName() );
		if ( updateFile.isFile() && FileUtil.copy( updateFile, file ) )
		{
			updateFile.delete();
		}
	}
	
	/**
	 * Checks if the given plugin is loaded and returns it when applicable
	 * <p>
	 * Please note that the name of the plugin is case-sensitive
	 * 
	 * @param name
	 *             Name of the plugin to check
	 * @return Plugin if it exists, otherwise null
	 */
	public synchronized Plugin getPlugin( String name )
	{
		return lookupNames.get( name );
	}
	
	public synchronized Plugin[] getPlugins()
	{
		return plugins.toArray( new Plugin[0] );
	}
	
	/**
	 * Checks if the given plugin is enabled or not
	 * <p>
	 * Please note that the name of the plugin is case-sensitive.
	 * 
	 * @param name
	 *             Name of the plugin to check
	 * @return true if the plugin is enabled, otherwise false
	 */
	public boolean isPluginEnabled( String name )
	{
		Plugin plugin = getPlugin( name );
		
		return isPluginEnabled( plugin );
	}
	
	/**
	 * Checks if the given plugin is enabled or not
	 * 
	 * @param plugin
	 *             Plugin to check
	 * @return true if the plugin is enabled, otherwise false
	 */
	public boolean isPluginEnabled( Plugin plugin )
	{
		if ( ( plugin != null ) && ( plugins.contains( plugin ) ) )
		{
			return plugin.isEnabled();
		}
		else
		{
			return false;
		}
	}
	
	public void enablePlugin( final Plugin plugin )
	{
		if ( !plugin.isEnabled() )
		{
			List<Command> pluginCommands = PluginCommandYamlParser.parse( plugin );
			
			if ( !pluginCommands.isEmpty() )
			{
				commandMap.registerAll( plugin.getDescription().getName(), pluginCommands );
			}
			
			try
			{
				plugin.getPluginLoader().enablePlugin( plugin );
			}
			catch ( Throwable ex )
			{
				Loader.getLogger().log( Level.SEVERE, "Error occurred (in the plugin loader) while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
			}
			
			HandlerList.bakeAll();
		}
	}
	
	public void disablePlugins()
	{
		Plugin[] plugins = getPlugins();
		for ( int i = plugins.length - 1; i >= 0; i-- )
		{
			disablePlugin( plugins[i] );
		}
	}
	
	public void disablePlugin( final Plugin plugin )
	{
		if ( plugin.isEnabled() )
		{
			try
			{
				plugin.getPluginLoader().disablePlugin( plugin );
			}
			catch ( Throwable ex )
			{
				Loader.getLogger().log( Level.SEVERE, "Error occurred (in the plugin loader) while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
			}
			
			try
			{
				Loader.getScheduler().cancelTasks( plugin );
			}
			catch ( Throwable ex )
			{
				Loader.getLogger().log( Level.SEVERE, "Error occurred (in the plugin loader) while cancelling tasks for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
			}
			
			try
			{
				Loader.getServicesManager().unregisterAll( plugin );
			}
			catch ( Throwable ex )
			{
				Loader.getLogger().log( Level.SEVERE, "Error occurred (in the plugin loader) while unregistering services for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
			}
			
			try
			{
				HandlerList.unregisterAll( plugin );
			}
			catch ( Throwable ex )
			{
				Loader.getLogger().log( Level.SEVERE, "Error occurred (in the plugin loader) while unregistering events for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
			}
			
			try
			{
				Loader.getMessenger().unregisterIncomingPluginChannel( plugin );
				Loader.getMessenger().unregisterOutgoingPluginChannel( plugin );
			}
			catch ( Throwable ex )
			{
				Loader.getLogger().log( Level.SEVERE, "Error occurred (in the plugin loader) while unregistering plugin channels for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
			}
		}
	}
	
	public void clearPlugins()
	{
		synchronized ( this )
		{
			disablePlugins();
			plugins.clear();
			lookupNames.clear();
			HandlerList.unregisterAll();
			fileAssociations.clear();
		}
	}
	
	public Plugin getPluginbyName( String pluginPath )
	{
		try
		{
			for ( Plugin plugin1 : getPlugins() )
			{
				if ( plugin1.getClass().getCanonicalName().equals( pluginPath ) || plugin1.getName().equalsIgnoreCase( pluginPath ) )
					return plugin1;
			}
		}
		catch ( Exception e )
		{
			e.printStackTrace();
		}
		
		return null;
	}
	
	public int broadcastMessage( String message )
	{
		return broadcast( message, Loader.BROADCAST_CHANNEL_USERS );
	}
	
	public int broadcast( String message, String permission )
	{
		int count = 0;
		Set<Permissible> permissibles = Loader.getPermissionsManager().getPermissionSubscriptions( permission );
		
		for ( Permissible permissible : permissibles )
		{
			if ( permissible instanceof Sentient && permissible.hasPermission( permission ) )
			{
				Sentient user = (Sentient) permissible;
				user.sendMessage( message );
				count++;
			}
		}
		
		return count;
	}
	
	public Map<String, String[]> getCommandAliases()
	{
		ConfigurationSection section = Loader.getConfig().getConfigurationSection( "aliases" );
		Map<String, String[]> result = new LinkedHashMap<String, String[]>();
		
		if ( section != null )
			for ( String key : section.getKeys( false ) )
			{
				List<String> commands;
				
				if ( section.isList( key ) )
					commands = section.getStringList( key );
				else
					commands = ImmutableList.of( section.getString( key ) );
				
				result.put( key, commands.toArray( new String[commands.size()] ) );
			}
		
		return result;
	}
	
	public PluginCommand getPluginCommand( String name )
	{
		Command command = commandMap.getCommand( name );
		
		if ( command instanceof PluginCommand )
			return (PluginCommand) command;
		else
			return null;
	}
	
	private void loadPlugin( Plugin plugin )
	{
		try
		{
			enablePlugin( plugin );
			
			List<Permission> perms = plugin.getDescription().getPermissions();
			
			for ( Permission perm : perms )
			{
				try
				{
					Loader.getPermissionsManager().addPermission( perm );
				}
				catch ( IllegalArgumentException ex )
				{
					Loader.getLogger().log( Level.WARNING, "Plugin " + plugin.getDescription().getFullName() + " tried to register permission '" + perm.getName() + "' but it's already registered", ex );
				}
			}
		}
		catch ( Throwable ex )
		{
			Loader.getLogger().log( Level.SEVERE, ex.getMessage() + " loading " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex );
		}
	}
	
	public AnonymousLoader getAnonLoader()
	{
		return anonLoader;
	}
}
