/**
 * Mozilla Public License, version 2.0
 *
 * 1. Definitions
 *
 * 1.1. “Contributor”
 *
 *      means each individual or legal entity that creates, contributes to the
 *      creation of, or owns Covered Software.
 *
 * 1.2. “Contributor Version”
 *
 *      means the combination of the Contributions of others (if any) used by a
 *      Contributor and that particular Contributor’s Contribution.
 *
 * 1.3. “Contribution”
 *
 *      means Covered Software of a particular Contributor.
 *
 * 1.4. “Covered Software”
 *
 *      means Source Code Form to which the initial Contributor has attached the
 *      notice in Exhibit A, the Executable Form of such Source Code Form, and
 *      Modifications of such Source Code Form, in each case including portions
 *      thereof.
 *
 * 1.5. “Incompatible With Secondary Licenses”
 *      means
 *
 *      a. that the initial Contributor has attached the notice described in
 *         Exhibit B to the Covered Software; or
 *
 *      b. that the Covered Software was made available under the terms of version
 *         1.1 or earlier of the License, but not also under the terms of a
 *         Secondary License.
 *
 * 1.6. “Executable Form”
 *
 *      means any form of the work other than Source Code Form.
 *
 * 1.7. “Larger Work”
 *
 *      means a work that combines Covered Software with other material, in a separate
 *      file or files, that is not Covered Software.
 *
 * 1.8. “License”
 *
 *      means this document.
 *
 * 1.9. “Licensable”
 *
 *      means having the right to grant, to the maximum extent possible, whether at the
 *      time of the initial grant or subsequently, any and all of the rights conveyed by
 *      this License.
 *
 * 1.10. “Modifications”
 *
 *      means any of the following:
 *
 *      a. any file in Source Code Form that results from an addition to, deletion
 *         from, or modification of the contents of Covered Software; or
 *
 *      b. any new file in Source Code Form that contains any Covered Software.
 *
 * 1.11. “Patent Claims” of a Contributor
 *
 *       means any patent claim(s), including without limitation, method, process,
 *       and apparatus claims, in any patent Licensable by such Contributor that
 *       would be infringed, but for the grant of the License, by the making,
 *       using, selling, offering for sale, having made, import, or transfer of
 *       either its Contributions or its Contributor Version.
 *
 * 1.12. “Secondary License”
 *
 *       means either the GNU General Public License, Version 2.0, the GNU Lesser
 *       General Public License, Version 2.1, the GNU Affero General Public
 *       License, Version 3.0, or any later versions of those licenses.
 *
 * 1.13. “Source Code Form”
 *
 *       means the form of the work preferred for making modifications.
 *
 * 1.14. “You” (or “Your”)
 *
 *       means an individual or a legal entity exercising rights under this
 *       License. For legal entities, “You” includes any entity that controls, is
 *       controlled by, or is under common control with You. For purposes of this
 *       definition, “control” means (a) the power, direct or indirect, to cause
 *       the direction or management of such entity, whether by contract or
 *       otherwise, or (b) ownership of more than fifty percent (50%) of the
 *       outstanding shares or beneficial ownership of such entity.
 *
 *
 * 2. License Grants and Conditions
 *
 * 2.1. Grants
 *
 *      Each Contributor hereby grants You a world-wide, royalty-free,
 *      non-exclusive license:
 *
 *      a. under intellectual property rights (other than patent or trademark)
 *         Licensable by such Contributor to use, reproduce, make available,
 *         modify, display, perform, distribute, and otherwise exploit its
 *         Contributions, either on an unmodified basis, with Modifications, or as
 *         part of a Larger Work; and
 *
 *      b. under Patent Claims of such Contributor to make, use, sell, offer for
 *         sale, have made, import, and otherwise transfer either its Contributions
 *         or its Contributor Version.
 *
 * 2.2. Effective Date
 *
 *      The licenses granted in Section 2.1 with respect to any Contribution become
 *      effective for each Contribution on the date the Contributor first distributes
 *      such Contribution.
 *
 * 2.3. Limitations on Grant Scope
 *
 *      The licenses granted in this Section 2 are the only rights granted under this
 *      License. No additional rights or licenses will be implied from the distribution
 *      or licensing of Covered Software under this License. Notwithstanding Section
 *      2.1(b) above, no patent license is granted by a Contributor:
 *
 *      a. for any code that a Contributor has removed from Covered Software; or
 *
 *      b. for infringements caused by: (i) Your and any other third party’s
 *         modifications of Covered Software, or (ii) the combination of its
 *         Contributions with other software (except as part of its Contributor
 *         Version); or
 *
 *      c. under Patent Claims infringed by Covered Software in the absence of its
 *         Contributions.
 *
 *      This License does not grant any rights in the trademarks, service marks, or
 *      logos of any Contributor (except as may be necessary to comply with the
 *      notice requirements in Section 3.4).
 *
 * 2.4. Subsequent Licenses
 *
 *      No Contributor makes additional grants as a result of Your choice to
 *      distribute the Covered Software under a subsequent version of this License
 *      (see Section 10.2) or under the terms of a Secondary License (if permitted
 *      under the terms of Section 3.3).
 *
 * 2.5. Representation
 *
 *      Each Contributor represents that the Contributor believes its Contributions
 *      are its original creation(s) or it has sufficient rights to grant the
 *      rights to its Contributions conveyed by this License.
 *
 * 2.6. Fair Use
 *
 *      This License is not intended to limit any rights You have under applicable
 *      copyright doctrines of fair use, fair dealing, or other equivalents.
 *
 * 2.7. Conditions
 *
 *      Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in
 *      Section 2.1.
 *
 *
 * 3. Responsibilities
 *
 * 3.1. Distribution of Source Form
 *
 *      All distribution of Covered Software in Source Code Form, including any
 *      Modifications that You create or to which You contribute, must be under the
 *      terms of this License. You must inform recipients that the Source Code Form
 *      of the Covered Software is governed by the terms of this License, and how
 *      they can obtain a copy of this License. You may not attempt to alter or
 *      restrict the recipients’ rights in the Source Code Form.
 *
 * 3.2. Distribution of Executable Form
 *
 *      If You distribute Covered Software in Executable Form then:
 *
 *      a. such Covered Software must also be made available in Source Code Form,
 *         as described in Section 3.1, and You must inform recipients of the
 *         Executable Form how they can obtain a copy of such Source Code Form by
 *         reasonable means in a timely manner, at a charge no more than the cost
 *         of distribution to the recipient; and
 *
 *      b. You may distribute such Executable Form under the terms of this License,
 *         or sublicense it under different terms, provided that the license for
 *         the Executable Form does not attempt to limit or alter the recipients’
 *         rights in the Source Code Form under this License.
 *
 * 3.3. Distribution of a Larger Work
 *
 *      You may create and distribute a Larger Work under terms of Your choice,
 *      provided that You also comply with the requirements of this License for the
 *      Covered Software. If the Larger Work is a combination of Covered Software
 *      with a work governed by one or more Secondary Licenses, and the Covered
 *      Software is not Incompatible With Secondary Licenses, this License permits
 *      You to additionally distribute such Covered Software under the terms of
 *      such Secondary License(s), so that the recipient of the Larger Work may, at
 *      their option, further distribute the Covered Software under the terms of
 *      either this License or such Secondary License(s).
 *
 * 3.4. Notices
 *
 *      You may not remove or alter the substance of any license notices (including
 *      copyright notices, patent notices, disclaimers of warranty, or limitations
 *      of liability) contained within the Source Code Form of the Covered
 *      Software, except that You may alter any license notices to the extent
 *      required to remedy known factual inaccuracies.
 *
 * 3.5. Application of Additional Terms
 *
 *      You may choose to offer, and to charge a fee for, warranty, support,
 *      indemnity or liability obligations to one or more recipients of Covered
 *      Software. However, You may do so only on Your own behalf, and not on behalf
 *      of any Contributor. You must make it absolutely clear that any such
 *      warranty, support, indemnity, or liability obligation is offered by You
 *      alone, and You hereby agree to indemnify every Contributor for any
 *      liability incurred by such Contributor as a result of warranty, support,
 *      indemnity or liability terms You offer. You may include additional
 *      disclaimers of warranty and limitations of liability specific to any
 *      jurisdiction.
 *
 * 4. Inability to Comply Due to Statute or Regulation
 *
 *    If it is impossible for You to comply with any of the terms of this License
 *    with respect to some or all of the Covered Software due to statute, judicial
 *    order, or regulation then You must: (a) comply with the terms of this License
 *    to the maximum extent possible; and (b) describe the limitations and the code
 *    they affect. Such description must be placed in a text file included with all
 *    distributions of the Covered Software under this License. Except to the
 *    extent prohibited by statute or regulation, such description must be
 *    sufficiently detailed for a recipient of ordinary skill to be able to
 *    understand it.
 *
 * 5. Termination
 *
 * 5.1. The rights granted under this License will terminate automatically if You
 *      fail to comply with any of its terms. However, if You become compliant,
 *      then the rights granted under this License from a particular Contributor
 *      are reinstated (a) provisionally, unless and until such Contributor
 *      explicitly and finally terminates Your grants, and (b) on an ongoing basis,
 *      if such Contributor fails to notify You of the non-compliance by some
 *      reasonable means prior to 60 days after You have come back into compliance.
 *      Moreover, Your grants from a particular Contributor are reinstated on an
 *      ongoing basis if such Contributor notifies You of the non-compliance by
 *      some reasonable means, this is the first time You have received notice of
 *      non-compliance with this License from such Contributor, and You become
 *      compliant prior to 30 days after Your receipt of the notice.
 *
 * 5.2. If You initiate litigation against any entity by asserting a patent
 *      infringement claim (excluding declaratory judgment actions, counter-claims,
 *      and cross-claims) alleging that a Contributor Version directly or
 *      indirectly infringes any patent, then the rights granted to You by any and
 *      all Contributors for the Covered Software under Section 2.1 of this License
 *      shall terminate.
 *
 * 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user
 *      license agreements (excluding distributors and resellers) which have been
 *      validly granted by You or Your distributors under this License prior to
 *      termination shall survive termination.
 *
 * 6. Disclaimer of Warranty
 *
 *    Covered Software is provided under this License on an “as is” basis, without
 *    warranty of any kind, either expressed, implied, or statutory, including,
 *    without limitation, warranties that the Covered Software is free of defects,
 *    merchantable, fit for a particular purpose or non-infringing. The entire
 *    risk as to the quality and performance of the Covered Software is with You.
 *    Should any Covered Software prove defective in any respect, You (not any
 *    Contributor) assume the cost of any necessary servicing, repair, or
 *    correction. This disclaimer of warranty constitutes an essential part of this
 *    License. No use of  any Covered Software is authorized under this License
 *    except under this disclaimer.
 *
 * 7. Limitation of Liability
 *
 *    Under no circumstances and under no legal theory, whether tort (including
 *    negligence), contract, or otherwise, shall any Contributor, or anyone who
 *    distributes Covered Software as permitted above, be liable to You for any
 *    direct, indirect, special, incidental, or consequential damages of any
 *    character including, without limitation, damages for lost profits, loss of
 *    goodwill, work stoppage, computer failure or malfunction, or any and all
 *    other commercial damages or losses, even if such party shall have been
 *    informed of the possibility of such damages. This limitation of liability
 *    shall not apply to liability for death or personal injury resulting from such
 *    party’s negligence to the extent applicable law prohibits such limitation.
 *    Some jurisdictions do not allow the exclusion or limitation of incidental or
 *    consequential damages, so this exclusion and limitation may not apply to You.
 *
 * 8. Litigation
 *
 *    Any litigation relating to this License may be brought only in the courts of
 *    a jurisdiction where the defendant maintains its principal place of business
 *    and such litigation shall be governed by laws of that jurisdiction, without
 *    reference to its conflict-of-law provisions. Nothing in this Section shall
 *    prevent a party’s ability to bring cross-claims or counter-claims.
 *
 * 9. Miscellaneous
 *
 *    This License represents the complete agreement concerning the subject matter
 *    hereof. If any provision of this License is held to be unenforceable, such
 *    provision shall be reformed only to the extent necessary to make it
 *    enforceable. Any law or regulation which provides that the language of a
 *    contract shall be construed against the drafter shall not be used to construe
 *    this License against a Contributor.
 *
 *
 * 10. Versions of the License
 *
 * 10.1. New Versions
 *
 *       Mozilla Foundation is the license steward. Except as provided in Section
 *       10.3, no one other than the license steward has the right to modify or
 *       publish new versions of this License. Each version will be given a
 *       distinguishing version number.
 *
 * 10.2. Effect of New Versions
 *
 *       You may distribute the Covered Software under the terms of the version of
 *       the License under which You originally received the Covered Software, or
 *       under the terms of any subsequent version published by the license
 *       steward.
 *
 * 10.3. Modified Versions
 *
 *       If you create software not governed by this License, and you want to
 *       create a new license for such software, you may create and use a modified
 *       version of this License if you rename the license and remove any
 *       references to the name of the license steward (except to note that such
 *       modified license differs from this License).
 *
 * 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses
 *       If You choose to distribute Source Code Form that is Incompatible With
 *       Secondary Licenses under the terms of this version of the License, the
 *       notice described in Exhibit B of this License must be attached.
 *
 * Exhibit A - Source Code Form License Notice
 *
 *       This Source Code Form is subject to the
 *       terms of the Mozilla Public License, v.
 *       2.0. If a copy of the MPL was not
 *       distributed with this file, You can
 *       obtain one at
 *       http://mozilla.org/MPL/2.0/.
 *
 * If it is not possible or desirable to put the notice in a particular file, then
 * You may include the notice in a location (such as a LICENSE file in a relevant
 * directory) where a recipient would be likely to look for such a notice.
 *
 * You may add additional accurate notices of copyright ownership.
 *
 * Exhibit B - “Incompatible With Secondary Licenses” Notice
 *
 *       This Source Code Form is “Incompatible
 *       With Secondary Licenses”, as defined by
 *       the Mozilla Public License, v. 2.0.
 */
package com.chiorichan.database;

import java.io.UnsupportedEncodingException;
import java.net.ConnectException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.json.JSONException;

import vnet.java.util.MySQLUtils;

import com.chiorichan.Loader;
import com.chiorichan.util.ObjectUtil;
import com.google.common.collect.Lists;
import com.mysql.jdbc.exceptions.jdbc4.CommunicationsException;
import com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException;

/**
 * Allows you to promote a SqlConnector as to provide a simple set of methods that make it easier to program inside Groovy Scripts.
 * 
 * @author Chiori Greene
 */
public class DatabaseEngine
{
	public Connection con;
	
	private String saved_db, saved_user, saved_pass, saved_host, saved_port;
	
	public DatabaseEngine()
	{
		
	}
	
	public DatabaseEngine(String db, String user, String pass) throws SQLException, ClassNotFoundException, ConnectException
	{
		init( db, user, pass, null, null );
	}
	
	public DatabaseEngine(String db, String user, String pass, String host) throws SQLException, ClassNotFoundException, ConnectException
	{
		init( db, user, pass, host, null );
	}
	
	public DatabaseEngine(String db, String user, String pass, String host, String port) throws SQLException, ClassNotFoundException, ConnectException
	{
		init( db, user, pass, host, port );
	}
	
	public DatabaseEngine(String filename) throws SQLException, ClassNotFoundException
	{
		init( filename );
	}
	
	/**
	 * Initializes a sqLite connection.
	 * 
	 * @param filename
	 * @throws SQLException
	 * @throws ClassNotFoundException
	 */
	public void init( String filename ) throws SQLException
	{
		try
		{
			Class.forName( "com.mysql.jdbc.Driver" );
		}
		catch ( ClassNotFoundException e )
		{
			Loader.getLogger().severe( "We could not locate the 'com.mysql.jdbc.Driver' library regardless that its suppose to be included. If your running from source code be sure to have this library in your build path." );
			System.exit( 1 );
		}
		
		con = DriverManager.getConnection( "jdbc:sqlite:" + filename );
		
		Loader.getLogger().info( "We succesully connected to the sqLite database using 'jdbc:sqlite:" + filename + "'" );
	}
	
	/**
	 * Initializes a mySQL connection.
	 * 
	 * @param db
	 * @param user
	 * @param pass
	 * @param host
	 * @param port
	 * @throws SQLException
	 * @throws ClassNotFoundException
	 * @throws ConnectException
	 */
	public void init( String db, String user, String pass, String host, String port ) throws SQLException
	{
		if ( host == null )
			host = "localhost";
		
		if ( port == null )
			port = "3306";
		
		try
		{
			Class.forName( "com.mysql.jdbc.Driver" );
		}
		catch ( ClassNotFoundException e )
		{
			Loader.getLogger().severe( "We could not locate the 'com.mysql.jdbc.Driver' library regardless that its suppose to be included. If your running from an IDE be sure to have this library in your build path." );
			System.exit( 1 );
		}
		
		saved_db = db;
		saved_user = user;
		saved_pass = pass;
		saved_host = host;
		saved_port = port;
		
		try
		{
			con = DriverManager.getConnection( "jdbc:mysql://" + host + ":" + port + "/" + db, user, pass );
		}
		catch ( SQLException e )
		{
			throw e;
		}
		
		if ( con != null && !con.isClosed() )
			Loader.getLogger().info( "We succesully connected to the sql database using 'jdbc:mysql://" + host + ":" + port + "/" + db + "'." );
		else
			Loader.getLogger().warning( "There was a problem connecting to the sql database using 'jdbc:mysql://" + host + ":" + port + "/" + db + "'." );
	}
	
	public LinkedHashMap<String, Object> selectOne( String table, List<String> keys, List<? extends Object> values ) throws SQLException
	{
		if ( con == null )
			throw new SQLException( "The SQL connection is closed or was never opened." );
		
		if ( isNull( keys ) || isNull( values ) )
		{
			Loader.getLogger().warning( "[DB ERROR] Either keys array or values array equals null!\n" );
			return null;
		}
		
		if ( keys.size() != values.size() )
		{
			System.err.print( "[DB ERROR] Keys array and values array must match in length!\n" );
			return null;
		}
		
		LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();
		
		String where = "";
		
		if ( keys.size() > 0 && values.size() > 0 )
		{
			int x = 0;
			String prefix = "";
			for ( String s : keys )
			{
				where += prefix + "`" + s + "` = '" + values.get( x ) + "'";
				x++;
				prefix = " AND ";
			}
		}
		
		ResultSet rs = query( "SELECT * FROM `" + table + "` WHERE " + where + " LIMIT 1;" );
		
		if ( rs != null && getRowCount( rs ) > 0 )
		{
			try
			{
				ResultSetMetaData rsmd = rs.getMetaData();
				int columnCount = rsmd.getColumnCount();
				
				do
				{
					for ( int i = 1; i < columnCount + 1; i++ )
					{
						result.put( rsmd.getColumnName( i ), rs.getObject( i ) );
					}
				}
				while ( rs.next() );
				
				return result;
			}
			catch ( Exception e )
			{
				e.printStackTrace();
			}
		}
		
		return null;
	}
	
	public Boolean isNull( Object o )
	{
		if ( o == null )
			return true;
		
		return false;
	}
	
	public int getRowCount( ResultSet rs )
	{
		try
		{
			// int curRow = rs.getRow();
			rs.last();
			int lastRow = rs.getRow();
			rs.first(); // TODO: Set the row???
			return lastRow;
		}
		catch ( Exception e )
		{
			return 0;
		}
	}
	
	public Boolean isConnected()
	{
		if ( con == null )
			return false;
		
		try
		{
			return !con.isClosed();
		}
		catch ( SQLException e )
		{
			return false;
		}
	}
	
	public Boolean reconnect()
	{
		try
		{
			if ( saved_host == null || saved_port == null || saved_db == null )
			{
				Loader.getLogger().severe( "There was an error reconnection to the DB, unknown cause other then connection string are NULL." );
				return false;
			}
			
			con = DriverManager.getConnection( "jdbc:mysql://" + saved_host + ":" + saved_port + "/" + saved_db, saved_user, saved_pass );
			Loader.getLogger().info( "We succesully connected to the sql database." );
		}
		catch ( Exception e )
		{
			Loader.getLogger().severe( "There was an error reconnection to the DB, " + "jdbc:mysql://" + saved_host + ":" + saved_port + "/" + saved_db + ", " + saved_user + " " + saved_pass, e );
		}
		
		return true;
	}
	
	public int queryUpdate( String query ) throws SQLException
	{
		int cnt = 0;
		
		if ( con == null )
			throw new SQLException( "The SQL connection is closed or was never opened." );
		
		try
		{
			PreparedStatement statement = con.prepareStatement( query );
			statement.execute();
			cnt = statement.getUpdateCount();
		}
		catch ( MySQLNonTransientConnectionException e )
		{
			if ( reconnect() )
				return queryUpdate( query );
		}
		catch ( CommunicationsException e )
		{
			if ( reconnect() )
				return queryUpdate( query );
		}
		catch ( Exception e )
		{
			e.printStackTrace();
		}
		
		Loader.getLogger().fine( "Update Query: \"" + query + "\" which affected " + cnt + " row(s)." );
		return cnt;
	}
	
	public ResultSet query( String query ) throws SQLException
	{
		return query( query, false );
	}
	
	public ResultSet query( String query, boolean retried ) throws SQLException
	{
		Statement stmt = null;
		ResultSet result = null;
		
		if ( con == null )
			throw new SQLException( "The SQL connection is closed or was never opened." );
		
		try
		{
			stmt = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );
			
			result = stmt.executeQuery( query );
			
			Loader.getLogger().fine( "SQL Query `" + query + "` returned " + getRowCount( result ) + " rows!" );
		}
		catch ( CommunicationsException | MySQLNonTransientConnectionException e )
		{
			if ( !retried && reconnect() )
				return query( query, true );
			else
			{
				throw e;
			}
		}
		catch ( Throwable t )
		{
			t.printStackTrace();
			throw t;
		}
		
		return result;
	}
	
	public Boolean update( String table, List<? extends Object> keys, List<? extends Object> values )
	{
		return update( table, keys, values, null, null );
	}
	
	public Boolean update( String table, List<? extends Object> keys, List<? extends Object> list, List<? extends Object> keysW, List<? extends Object> valuesW )
	{
		if ( isNull( keys ) || isNull( list ) )
		{
			System.err.print( "[DB ERROR] Either keys array or values array equals null!\n" );
			return false;
		}
		
		if ( keys.size() != list.size() )
		{
			System.err.print( "[DB ERROR] Keys array and values array must match in length!\n" );
			return false;
		}
		
		if ( keysW.size() != valuesW.size() )
		{
			System.err.print( "[DB ERROR] Where keys array and where values array must match in length!\n" );
			return false;
		}
		
		if ( keys.size() < 1 )
		{
			System.err.print( "[DB ERROR] The keys to be updated can not be empty!\n" );
			return false;
		}
		
		String where = "";
		String update = "";
		
		int x = 0;
		String prefix = "";
		
		for ( Object s : keys )
		{
			update += prefix + "`" + s + "` = '" + list.get( x ) + "'";
			x++;
			prefix = ", ";
		}
		
		if ( !isNull( keysW ) && !isNull( valuesW ) && keysW.size() > 0 && valuesW.size() > 0 )
		{
			x = 0;
			prefix = "";
			
			for ( Object s : keysW )
			{
				where += prefix + "`" + s + "` = '" + valuesW.get( x ) + "'";
				x++;
				prefix = " AND ";
			}
			
			if ( where.length() > 0 )
				where = " WHERE " + where;
		}
		
		int cnt = 0;
		try
		{
			cnt = queryUpdate( "UPDATE " + table + " SET " + update + where + ";" );
		}
		catch ( SQLException e )
		{
			e.printStackTrace();
			return false;
		}
		
		return ( cnt > 0 );
	}
	
	public LinkedHashMap<String, Object> selectOne( String table, String key, String val ) throws SQLException
	{
		return selectOne( table, Arrays.asList( key ), Arrays.asList( val ) );
	}
	
	public static LinkedHashMap<String, Object> convert( ResultSet rs ) throws SQLException, JSONException
	{
		LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();
		int x = 0;
		
		rs.first();
		
		do
		{
			result.put( "" + x, convertRow( rs ) );
			x++;
		}
		while ( rs.next() );
		
		return result;
	}
	
	public static LinkedHashMap<String, Object> convertRow( ResultSet rs ) throws SQLException, JSONException
	{
		LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();
		ResultSetMetaData rsmd = rs.getMetaData();
		
		int numColumns = rsmd.getColumnCount();
		
		for ( int i = 1; i < numColumns + 1; i++ )
		{
			String column_name = rsmd.getColumnName( i );
			
			// Loader.getLogger().info( "Column: " + column_name + " <-> " + rsmd.getColumnTypeName( i ) );
			
			if ( rsmd.getColumnType( i ) == java.sql.Types.ARRAY )
			{
				result.put( column_name, rs.getArray( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.BIGINT )
			{
				result.put( column_name, rs.getInt( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.TINYINT )
			{
				result.put( column_name, rs.getInt( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.BIT ) // Sometimes tinyints are read as bits
			{
				result.put( column_name, rs.getInt( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.BOOLEAN )
			{
				result.put( column_name, rs.getBoolean( column_name ) );
			}
			else if ( rsmd.getColumnTypeName( i ) == "BLOB" || rsmd.getColumnTypeName( i ) == "LONGBLOB" )
			{
				byte[] bytes = rs.getBytes( column_name );
				
				try
				{
					result.put( column_name, new String( bytes, "ISO-8859-1" ) );
				}
				catch ( UnsupportedEncodingException e )
				{
					e.printStackTrace();
				}
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.DOUBLE )
			{
				result.put( column_name, rs.getDouble( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.FLOAT )
			{
				result.put( column_name, rs.getFloat( column_name ) );
			}
			else if ( rsmd.getColumnTypeName( i ) == "INT" )
			{
				result.put( column_name, rs.getInt( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.NVARCHAR )
			{
				result.put( column_name, rs.getNString( column_name ) );
			}
			else if ( rsmd.getColumnTypeName( i ) == "VARCHAR" )
			{
				result.put( column_name, rs.getString( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.SMALLINT )
			{
				result.put( column_name, rs.getInt( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.DATE )
			{
				result.put( column_name, rs.getDate( column_name ) );
			}
			else if ( rsmd.getColumnType( i ) == java.sql.Types.TIMESTAMP )
			{
				result.put( column_name, rs.getTimestamp( column_name ) );
			}
			else
			{
				result.put( column_name, rs.getObject( column_name ) );
			}
		}
		
		// Loader.getLogger().info( result.toString() );
		
		return result;
	}
	
	public ResultSetMetaData getTableMetaData( String table ) throws SQLException
	{
		ResultSet rs = query( "SELECT * FROM " + table );
		return rs.getMetaData();
	}
	
	public List<String> getTableFieldNames( String table ) throws SQLException
	{
		List<String> rtn = Lists.newArrayList();
		
		ResultSet rs = query( "SELECT * FROM " + table );
		
		ResultSetMetaData rsmd = rs.getMetaData();
		
		int numColumns = rsmd.getColumnCount();
		
		for ( int i = 1; i < numColumns + 1; i++ )
		{
			rtn.add( rsmd.getColumnName( i ) );
		}
		
		return rtn;
	}
	
	public List<String> getTableFieldTypes( String table ) throws SQLException
	{
		List<String> rtn = Lists.newArrayList();
		
		ResultSet rs = query( "SELECT * FROM " + table );
		
		ResultSetMetaData rsmd = rs.getMetaData();
		
		int numColumns = rsmd.getColumnCount();
		
		for ( int i = 1; i < numColumns + 1; i++ )
		{
			rtn.add( rsmd.getColumnTypeName( i ) );
		}
		
		return rtn;
	}
	
	@SuppressWarnings( "unchecked" )
	public LinkedHashMap<String, Object> selectOne( String table, Object where ) throws SQLException
	{
		LinkedHashMap<String, Object> result = select( table, where );
		
		if ( result == null || result.size() < 1 )
			return null;
		
		return (LinkedHashMap<String, Object>) result.get( "0" );
	}
	
	public LinkedHashMap<String, Object> select( String table ) throws SQLException
	{
		return select( table, null, null );
	}
	
	public LinkedHashMap<String, Object> select( String table, Object where ) throws SQLException
	{
		return select( table, where, null );
	}
	
	@SuppressWarnings( "unchecked" )
	public LinkedHashMap<String, Object> select( String table, Object where, Map<String, Object> options0 ) throws SQLException
	{
		String subWhere = "";
		
		String whr = "";
		
		if ( where instanceof String )
		{
			whr = ( (String) where );
		}
		else if ( where instanceof Map )
		{
			Map<String, Object> whereMap = (Map<String, Object>) where;
			
			String tmp = "", opr = "";// , opr2 = "";
			
			for ( Entry<String, Object> entry : whereMap.entrySet() )
			{
				if ( entry.getValue() instanceof Map )
				{
					opr = "AND";
					if ( entry.getKey().indexOf( "|" ) >= 0 )
						opr = "OR";
					if ( entry.getKey().indexOf( "&" ) >= 0 )
						opr = "AND";
					
					String tmp2 = "";
					Map<String, Object> val = (Map<String, Object>) entry.getValue();
					
					for ( Entry<String, Object> entry2 : val.entrySet() )
					{
						// opr2 = "AND";
						if ( entry.getKey().indexOf( "|" ) >= 0 )
							opr = "OR";
						if ( entry.getKey().indexOf( "&" ) >= 0 )
							opr = "AND";
						
						String key = entry2.getKey().replace( "|", "" ).replace( "&", "" );
						tmp2 = "`" + key + "` = '" + entry2.getValue() + "'";
						tmp += ( tmp.isEmpty() ) ? tmp2 : subWhere + " " + opr + " " + tmp2;
					}
					
					whr = ( whr.isEmpty() ) ? "(" + tmp + ")" : whr + " " + opr + " (" + tmp + ")";
				}
				else
				{
					opr = "AND";
					if ( entry.getKey().indexOf( "|" ) >= 0 )
						opr = "OR";
					if ( entry.getKey().indexOf( "&" ) >= 0 )
						opr = "AND";
					
					String key = entry.getKey().replace( "|", "" ).replace( "&", "" );
					
					tmp = "`" + key + "` = '" + entry.getValue() + "'";
					whr = ( whr.isEmpty() ) ? tmp : whr + " " + opr + " " + tmp;
				}
			}
		}
		else
		{
			whr = "";
		}
		
		Map<String, String> options = new LinkedHashMap<String, String>();
		
		if ( options0 != null )
			for ( Entry<String, Object> o : options0.entrySet() )
			{
				options.put( o.getKey().toLowerCase(), ObjectUtil.castToString( o.getValue() ) );
			}
		
		if ( !options.containsKey( "limit" ) || !( options.get( "limit" ) instanceof String ) )
			options.put( "limit", "0" );
		if ( !options.containsKey( "offset" ) || !( options.get( "offset" ) instanceof String ) )
			options.put( "offset", "0" );
		if ( !options.containsKey( "orderby" ) )
			options.put( "orderby", "" );
		if ( !options.containsKey( "groupby" ) )
			options.put( "groupby", "" );
		if ( !options.containsKey( "fields" ) )
			options.put( "fields", "*" );
		
		String limit = ( Integer.parseInt( options.get( "limit" ) ) > 0 ) ? " LIMIT " + Integer.parseInt( options.get( "offset" ) ) + ", " + Integer.parseInt( options.get( "limit" ) ) : "";
		String orderby = ( (String) options.get( "orderby" ) ) == "" ? "" : " ORDER BY " + ( (String) options.get( "orderby" ) );
		String groupby = ( (String) options.get( "groupby" ) ) == "" ? "" : " GROUP BY " + ( (String) options.get( "groupby" ) );
		
		where = ( whr.isEmpty() ) ? "" : " WHERE " + whr;
		
		String query = "SELECT " + ( (String) options.get( "fields" ) ) + " FROM `" + table + "`" + where + groupby + orderby + limit + ";";
		
		// TODO: Act on result!
		SQLInjectionDetection( query );
		
		ResultSet rs = query( query );
		
		if ( rs == null )
		{
			Loader.getLogger().fine( "Making SELECT query \"" + query + "\" which returned an error." );
			return null;
		}
		
		if ( getRowCount( rs ) < 1 )
		{
			Loader.getLogger().fine( "Making SELECT query \"" + query + "\" which returned no results." );
			return new LinkedHashMap<String, Object>();
		}
		
		LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();
		try
		{
			result = convert( rs );
		}
		catch ( JSONException e )
		{
			e.printStackTrace();
		}
		
		Loader.getLogger().fine( "Making SELECT query \"" + query + "\" which returned " + getRowCount( rs ) + " row(s)." );
		
		return result;
	}
	
	/**
	 * Checks Query String for Attempted SQL Injection by Checking for Certain Commands After the First 6 Characters.
	 * Warning: This Check Will Return True (or Positive) if You Check A Query That Inserts an Image.
	 */
	public boolean SQLInjectionDetection( String query )
	{
		query = query.toUpperCase();
		boolean safe = false;
		
		String[] unSafeWords = new String[] { "SELECT", "UPDATE", "DELETE", "INSERT", "UNION", "--" };
		
		String splice = query.substring( 0, 6 );
		
		for ( String word : unSafeWords )
		{
			if ( splice.equals( word ) )
			{
				safe = true;
			}
		}
		
		if ( !safe )
			return false;
		// GetFramework()->getServer()->Panic(400, "SQL Injection Detected! Notify administrators ASAP. Debug \"" .
		// $QueryString . "\".");
		
		splice = query.substring( 6 );
		for ( String word : unSafeWords )
		{
			if ( splice.contains( word ) )
			{
				safe = false;
			}
		}
		
		return safe;
		// GetFramework()->getServer()->Panic(400, "SQL Injection Detected! Notify administrators ASAP. Debug \"" .
		// $QueryString . "\".");
	}
	
	public boolean update( String table, Map<String, Object> data )
	{
		return update( table, data, "", 1, false );
	}
	
	public boolean update( String table, Map<String, Object> data, Object where )
	{
		return update( table, data, where, 1, false );
	}
	
	public boolean update( String table, Map<String, Object> data, Object where, int lmt )
	{
		return update( table, data, where, lmt, false );
	}
	
	@SuppressWarnings( "unchecked" )
	public boolean update( String table, Map<String, Object> data, Object where, int lmt, boolean disableInjectionCheck )
	{
		String subWhere = "";
		
		String whr = "";
		
		if ( where instanceof String )
		{
			whr = ( (String) where );
		}
		else if ( where instanceof Map )
		{
			Map<String, Object> whereMap = (Map<String, Object>) where;
			
			String tmp = "", opr = "";// , opr2 = "";
			
			for ( Entry<String, Object> entry : whereMap.entrySet() )
			{
				if ( entry.getValue() instanceof Map )
				{
					opr = "AND";
					if ( entry.getKey().indexOf( "|" ) >= 0 )
						opr = "OR";
					if ( entry.getKey().indexOf( "&" ) >= 0 )
						opr = "AND";
					
					String tmp2 = "";
					Map<String, Object> val = (Map<String, Object>) entry.getValue();
					
					for ( Entry<String, Object> entry2 : val.entrySet() )
					{
						// opr2 = "AND";
						if ( entry.getKey().indexOf( "|" ) >= 0 )
							opr = "OR";
						if ( entry.getKey().indexOf( "&" ) >= 0 )
							opr = "AND";
						
						String key = entry2.getKey().replace( "|", "" ).replace( "&", "" );
						tmp2 = "`" + key + "` = '" + entry2.getValue() + "'";
						tmp += ( tmp.isEmpty() ) ? tmp2 : subWhere + " " + opr + " " + tmp2;
					}
					
					whr = ( whr.isEmpty() ) ? "(" + tmp + ")" : whr + " " + opr + " (" + tmp + ")";
				}
				else
				{
					opr = "AND";
					if ( entry.getKey().indexOf( "|" ) >= 0 )
						opr = "OR";
					if ( entry.getKey().indexOf( "&" ) >= 0 )
						opr = "AND";
					
					String key = entry.getKey().replace( "|", "" ).replace( "&", "" );
					
					tmp = "`" + key + "` = '" + entry.getValue() + "'";
					whr = ( whr.isEmpty() ) ? tmp : whr + " " + opr + " " + tmp;
				}
			}
		}
		else
		{
			whr = "";
		}
		
		String limit = ( lmt > 0 ) ? " LIMIT " + lmt : "";
		where = ( whr.isEmpty() ) ? "" : " WHERE " + whr;
		
		String set = "";
		
		for ( Entry<String, Object> e : data.entrySet() )
			set += ", `" + e.getKey() + "` = '" + e.getValue() + "'";
		
		if ( set.length() > 2 )
			set = set.substring( 2 );
		
		String query = "UPDATE " + table + " SET " + set + where + limit + ";";
		
		if ( !disableInjectionCheck )
			SQLInjectionDetection( query );
		
		int result = 0;
		try
		{
			result = queryUpdate( query );
		}
		catch ( SQLException e )
		{
			e.printStackTrace();
		}
		
		if ( result > 0 )
		{
			Loader.getLogger().fine( "Making UPDATE query \"" + query + "\" which affected " + result + " rows." );
			return true;
		}
		else
		{
			Loader.getLogger().fine( "Making UPDATE query \"" + query + "\" which had no affect on the database." );
			return false;
		}
	}
	
	public boolean delete( String table, Map<String, Object> where )
	{
		return delete( table, where, 1 );
	}
	
	@SuppressWarnings( "unchecked" )
	public boolean delete( String table, Map<String, Object> where, int limit )
	{
		String whr = "";
		
		String tmp = "", opr = "";// , opr2 = "";
		
		for ( Entry<String, Object> entry : where.entrySet() )
		{
			if ( entry.getValue() instanceof Map )
			{
				opr = "AND";
				if ( entry.getKey().indexOf( "|" ) >= 0 )
					opr = "OR";
				if ( entry.getKey().indexOf( "&" ) >= 0 )
					opr = "AND";
				
				String tmp2 = "";
				Map<String, Object> val = (Map<String, Object>) entry.getValue();
				
				for ( Entry<String, Object> entry2 : val.entrySet() )
				{
					// opr2 = "AND";
					if ( entry.getKey().indexOf( "|" ) >= 0 )
						opr = "OR";
					if ( entry.getKey().indexOf( "&" ) >= 0 )
						opr = "AND";
					
					String key = entry2.getKey().replace( "|", "" ).replace( "&", "" );
					tmp2 = "`" + key + "` = '" + entry2.getValue() + "'";
					tmp += ( tmp.isEmpty() ) ? tmp2 : opr + " " + tmp2;
				}
				
				whr = ( whr.isEmpty() ) ? "(" + tmp + ")" : whr + " " + opr + " (" + tmp + ")";
			}
			else
			{
				opr = "AND";
				if ( entry.getKey().indexOf( "|" ) >= 0 )
					opr = "OR";
				if ( entry.getKey().indexOf( "&" ) >= 0 )
					opr = "AND";
				
				String key = entry.getKey().replace( "|", "" ).replace( "&", "" );
				
				tmp = "`" + key + "` = '" + entry.getValue() + "'";
				whr = ( whr.isEmpty() ) ? tmp : whr + " " + opr + " " + tmp;
			}
		}
		
		return delete( table, whr, limit );
	}
	
	public boolean delete( String table, String where )
	{
		return delete( table, where, 1 );
	}
	
	public boolean delete( String table, String where, int limit )
	{
		String lmt = "";
		if ( limit > 0 )
			lmt = " LIMIT 1";
		
		int i = 0;
		try
		{
			i = queryUpdate( "DELETE FROM `" + table + "` WHERE " + where + lmt + ";" );
		}
		catch ( SQLException e )
		{
			e.printStackTrace();
		}
		
		Loader.getLogger().fine( "Deleting from table " + table + " where " + where + " " + i );
		
		return true;
	}
	
	public boolean insert( String table, Map<String, Object> data )
	{
		return insert( table, data, false );
	}
	
	public boolean insert( String table, Map<String, Object> where, boolean disableInjectionCheck )
	{
		String keys = "";
		String values = "";
		
		for ( Entry<String, Object> e : where.entrySet() )
		{
			String key = escape( e.getKey() );
			
			String value;
			try
			{
				value = escape( (String) e.getValue() );
			}
			catch ( Exception ee )
			{
				value = ObjectUtil.castToString( e.getValue() );
			}
			
			if ( keys.isEmpty() )
			{
				keys = "`" + key + "`";
			}
			else
			{
				keys += ", `" + key + "`";
			}
			
			if ( values.isEmpty() )
			{
				values = "'" + value + "'";
			}
			else
			{
				values += ", '" + value + "'";
			}
		}
		
		String query = "INSERT INTO " + table + " (" + keys + ")VALUES(" + values + ");";
		
		if ( !disableInjectionCheck && query.length() < 255 )
			SQLInjectionDetection( query );
		
		int result = 0;
		try
		{
			result = queryUpdate( query );
		}
		catch ( SQLException e )
		{
			e.printStackTrace();
		}
		
		if ( result > 0 )
		{
			Loader.getLogger().fine( "Making INSERT query \"" + query + "\" which affected " + result + " rows." );
			return true;
		}
		else
		{
			Loader.getLogger().fine( "Making INSERT query \"" + query + "\" which had no affect on the database" );
			return false;
		}
	}
	
	public String escape( String str )
	{
		return MySQLUtils.escape( str );
	}
}
